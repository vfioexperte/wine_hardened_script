#!/usr/bin/env python3
#Copyright (C) 2022  vfio_experte
#This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
#This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#You should have received a copy of the GNU General Public License along with this program; if not, see <http://www.gnu.org/licenses/>.
#this is a fork from https://github.com/kritzsie/steam-on-docker
#start project 04.02.2021


#last edit 13.03.2022

version = "0.28r"
appname = "sebs docker contianer gaming app"
#0.28r json gui 0.3f_6  virgl hot fix 0.1a
#0.28q gpu redner not loading by encrypt file 1.0 #json file 0.3f_3
#0.28o pacman cahche empty
#0.28o wayland support 0.1a
#0.28n build failed fix 0.1a
#0.28m add DRI_PRIME reading fix 0.2a #create_links 0.1a
#0.28k #0.3f_3 json_edit_gui add a scrollbar
#0.28i patching_lib .3d add new file /etc/user_patched2.bash and fix faketime 0.1a
#json_file.py loading bug fix 1 + json gui rechtscheibung fix 1
#0.28g docker_build standard fix 0.1a
#0.28f bearbeitung schutz 0.1a mit Fernet
#0.28e 32bit speed hak "sysctl -w abi.vsyscall32=0"

print(version);

import platform
import os
import sys
import string
import subprocess
import time

#from PyQt5 import QtWidgets
#from PyQt5 import QtGui
import math

import json

from Code.Json.json_file import *
from Code.Path.path_lib import *
from Code.Patching.patching_lib import *
from Code.Usb.usb_lib import *
from Code.Cd_Rom.cdrom_lib import *
from Code.Gui.json_edit_gui.json_edit_gui import *
from Code.Xinput.xinput_lib import *
from Code.Bluethooth.bluethooth_lib import *
from Code.Crypt.rsa_lib import *

jason_data = {};

#app = QtWidgets.QApplication(sys.argv)

pacman_downloads = 3;

pacman_pkgage_install = "unbound qt5pas teamspeak3 python-ntlm-auth  python-requests-ntlm perl-ntlm python-ntlm-auth python-requests-ntlm  lutris python-beaker python-mako valgrind llvm lib32-llvm meson vulkan-swrast net-tools wireguard-tools nautilus shared-mime-info gdk-pixbuf2 thunderbird-i18n-de python-pyqt5  gnu-netcat opendoas retroarch-assets-glui retroarch-assets-ozone ninja ccache glm openvr yad archlinux-keyring base base-devel xf86-video-ati xf86-video-amdgpu  xorg xorg-server xorg-xinit mesa-demos vulkan-tools  vulkan-mesa-layers vulkan-radeon  vulkan-icd-loader pulseaudio alsa-tools alsa-utils pulseaudio-alsa pavucontrol  wine lib32-mpg123 openra winetricks openal firefox-i18n-de xfce4-terminal openvpn dotnet-runtime dotnet-sdk thunar ntfs-3g exfat-utils boost mpv desmume mgba-qt mgba-sdl xfce4 xfce4-goodies blender opencl-mesa  gst-plugins-ugly  qt5-webengine qt5-base qt5-multimedia qt5-tools fmt libxkbcommon-x11 sdl2 desktop-file-utils shared-mime-info nlohmann-json boost catch2 cmake git  nano adriconf   qt5-webglplugin qt5-webkit qt5-websockets qt5-webview  veracrypt desmume libretro-desmume nano p7zip snes9x retroarch libretro-mesen  mgba-qt python-pyqt5 mkvtoolnix-gui k3b qt5 sndio rkhunter qutebrowser hexedit youtube-dl vlc lib32-libpulse lib32-alsa-plugins hexedit qutebrowser youtube-dl obs-studio cdemu-client  cdemu-daemon vhba-module-dkms  virtualbox blender  gimp gimp-help-de   nfs-utils rsync subversion qemu cdrtools dolphin-emu lib32-mesa-vdpau mesa-vdpau  lib32-vulkan-radeon vulkan-radeon lib32-libva-mesa-driver libva-mesa-driver exfat-utils  python3 python-pip   python2-pip  python2 python-lz4 python2-apipkg python-lz4 python python-setuptools python-pip gphoto2 gvfs-gphoto2 libgphoto2  mono  wine-mono wine_gecko kvantum-qt5   qtcreator  falkon glfw-x11  git cmake  gcc clang htop shotcut archiso vulkan-headers vulkan-tools vulkan-extra-layers gimp-nufraw xdotool xorg-xinput gnu-netcat   gimp-help-de opencl-mesa  firefox-i18n-de vkd3d lib32-vkd3d  gparted libreoffice-still-de  inkscape  partclone pigz gedit pkgstats scons python-pyusb clamav clamtk  cura encfs playonlinux cura encfs steam xmlto docbook-xsl kmod inetutils bc git libelf steam-native-runtime xreader rawtherapee  nautilus minetest-server minetest";


tmpfile = "/tmp/lsscsi1i3u45hz835z8345z3-384534875z3485z487";

config_file = ".config";
config_file_json = "config.json";


lsusb_temp_file = "/tmp/873264832654893775963457967hsdifhreufgdurbgfkuseb"

def brechen_config(name, value):
    return [name, value]

def system(cmd):
    try:
        output = subprocess.check_output(cmd, shell=True).decode().split("\n");
        return output;
    except subprocess.CalledProcessError:
        return "";
    except FileNotFoundError:
        return "";

devices = read_steam_Controller();

def filter_docker_build(cmdarray):
    i = 0;
    out = [];
    while True:
        if(i >= len(cmdarray)):
            break;
        tmp = cmdarray[i];
        if(tmp == "--privileged"):
            i = i +1;
            continue;
        elif(tmp == "-e"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "-v"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "--group-add"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "--device"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "-h"):
            i = i + 1;
            i = i +1;
            continue;

        else:
            out.append(tmp);
        i = i +1;
    return out;


def read_docker_ps(suche):
    try:
        cmd = subprocess.check_output("docker ps ", shell=True).decode().split("\n");
        for tmp in cmd:
            if(tmp.split()[0] == "CONTAINER"):
                continue;
            elif(tmp.split()[1] == suche):
                return tmp.split()[0];
        return "";
    except subprocess.CalledProcessError:
        return "";
    except FileNotFoundError:
        return "";
    except IndexError:
        return "";

def args_array_to_str(array):
    s1 = "";
    for tmp in array:
        s1 = s1 + tmp + " ";
    return s1;

def wait_build_fertig(sfile, dirname_tmp):
    dockerid = read_docker_ps(dirname_tmp);
    if(os.path.isfile(sfile) == True):
        os.remove(sfile);
    while True:
        id = read_docker_ps(dirname_tmp);
        if(id != dockerid):
            print("ERROR dcoekr coantiner is exit can not svae it!");
            exit();
        if(os.path.isfile(sfile) == True):
            os.remove(sfile);
            break;
    return 0;

import threading

class cmd_thread(threading.Thread):
    def __init__(self):
        super(cmd_thread, self).__init__()
        self.total=0
    def set(self, cmd):
        self.cmd = cmd;
        self.exit = 0;
        return 0;
    def run(self):
        #system(self.cmd);
        #cmd = subprocess.check_output(self.cmd, shell=True).decode();
        os.system(self.cmd);
        #print(cmd);
        self.exit = 1;
    def exit(self):
        return self.exit;

thread = cmd_thread();

def start_thread_wait(cmd):
    out = system(cmd);
    for tmp in out:
        tmp2 = tmp.split("EXITCODE--EXITCODE ");
        if(len(tmp2) >= 2):
            return int(tmp2[1][0]);
    if(out == ""):
        return 1;
    return 0;

def start_thread(cmd):
    thread.set(cmd);
    thread.start();
    return 0;

def thread_wait_is_exit():
    thread.join();
    return 0;

def array_add_aarray(array1, addarraay):
    for tmp in addarraay:
        array1.append(tmp);
    return array1;

def read_args():
    b1 = 0;
    i = 1;
    s1 = "";
    while True:
        if(i >= len(sys.argv)):
            break;
        s2 = sys.argv[i];
        if(s2.find("\\n") != -1):
            a1 = s2.split("\\n");
            for tmp in a1:
                if(i != 1 and tmp.find(" ") != -1):
                    s1 = s1 + " '" + tmp + "' \n";
                else:
                    s1 = s1 + " " + tmp + " \n";

        elif(i != 1 and s2.find(" ") != -1):
            s1 = s1 + " '" + s2 + "' ";
        else:
            s1 = s1 + " " + s2 + " ";

        i = i +1;
    print("read_args: ", s1);
    return s1;

def gpu_Render_check_is_int(gpu_render):
    try:
        i = int(gpu_render);
        return 1;
    except ValueError:
        return 0;


def create_links():
    os.system("ln -sf build login_root")
    os.system("ln -sf build login")
    os.system("ln -sf build run")
    os.system("ln -sf build openra-ra")
    os.system("ln -sf build firefox")
    os.system("ln -sf build command")
    os.system("ln -sf build command_root")
    os.system("ln -sf build edit_config")
    return 0;

def check_env(s1):
    try:
        s2 = os.environ[s1];
        return s2;
    except KeyError:
        return -1;

def main():
    create_links();
    sargs = read_args();
    nosudo = 1;
    docker_user = "empty"
    docker_build = "archlinux_std_docker";
    gpu_render = "0";
    gpu_render_2 = "0";

    disk_device_name = "cd/dvd";
    zugriff_auf_media = 0; #1 = True
    sav_home_docker_folder = 0;
    share_folder_daten = 0;
    share_folder1_aktiv = 0;
    share_folder1 = "";
    network_disable = 0;
    steam_controller_bool = 0;
    usb_sharing = 0;
    usb_name = ""
    usb_hidraw_name = "";#cat < /sys/class/hidraw/hidraw5/device/uevent | grep "Valve Software Steam Controller"

    abspath = os.path.abspath(sys.argv[0])
    basename = os.path.basename(abspath)
    dirname = os.path.dirname(abspath)
    config = loading_json_file(dirname + "/config_file_json");

    docker_input = "";
    maxmemory = -1;
    maxcpus = -1;
    network_host = "0";
    portforwding = "";
    dbus_rw = 0;
    pacman_cache = "";
    dns = "";
    ipv4 = "";
    wireguard_fix = 0;
    run_in_background = 0;
    ttyon = 0;
    pacman_pakgage_install = pacman_pkgage_install;
    bluethoot_passthrough = 0;
    hidraw_acs_overrides_patch = 0;
    ipv6_privacy = 0;
    faketime = "";
    wine_32bit_speed_hak = 0;
    read_only = "";
    read_only_password = "";
    json_config_Verison = "";


    i = 0;
    while True:
        if(i >= len(config)):
            break;
        tmp = config[i];
        if(tmp[0] == "docker_user"):
            docker_user = tmp[1];
        elif(tmp[0] == "gpu_render"):
            gpu_render = tmp[1];
        elif(tmp[0] == "disk_device_name"):
            disk_device_name = tmp[1];
        elif(tmp[0] == "zugriff_auf_media"):
            zugriff_auf_media = int(tmp[1]);
        elif(tmp[0] == "sav_home_docker_folder"):
            sav_home_docker_folder = int(tmp[1]);
        elif(tmp[0] == "share_folder_daten"):
            share_folder_daten = int(tmp[1]);
        elif(tmp[0] == "share_folder1_aktiv"):
            share_folder1_aktiv = int(tmp[1]);
        elif(tmp[0] == "share_folder1"):
            share_folder1 = tmp[1];
        elif(tmp[0] == "network_disable"):
            network_disable = int(tmp[1]);
        elif(tmp[0] == "steam_controller_bool"):
            steam_controller_bool = int(tmp[1]);
        elif(tmp[0] == "usb_sharing"):
            usb_sharing = int(tmp[1]);
        elif(tmp[0] == "usb_name"):
            usb_name = tmp[1];
        elif(tmp[0] == "usb_hidraw_name"):
            usb_hidraw_name = tmp[1];
        elif(tmp[0] == "docker_build"):
            docker_build = tmp[1];
        elif(tmp[0] == "docker_input"):
            docker_input = tmp[1];
        elif(tmp[0] == "maxmemory"):
            maxmemory = int(tmp[1]);
        elif(tmp[0] == "maxcpus"):
            maxcpus = int(tmp[1]);
        elif(tmp[0] == "network_host"):
            network_host = tmp[1];
        elif(tmp[0] == "portforwding"):
            portforwding = tmp[1];
        elif(tmp[0] == "dbus_rw"):
            dbus_rw = int(tmp[1]);
        elif(tmp[0] == "pacman_cache"):
            pacman_cache = tmp[1];
        elif(tmp[0] == "dns"):
            dns = tmp[1];
        elif(tmp[0] == "ipv4"):
            ipv4 = tmp[1];
        elif(tmp[0] == "wireguard_fix"):
            wireguard_fix = int(tmp[1]);
        elif(tmp[0] == "nosudo"):
            nosudo = int(tmp[1]);
        elif(tmp[0] == "run_in_background"):
            run_in_background = int(tmp[1]);
        elif(tmp[0] == "ttyon"):
            ttyon = int(tmp[1]);
        elif(tmp[0] == "pacman_pakgage_install"):
            pacman_pakgage_install = tmp[1];
            print("pacman_pakgage_install aktiv!");
        elif(tmp[0] == "bluethoot_passthrough"):
            bluethoot_passthrough = int(tmp[1]);
            print("bluethoot_passthrough aktiv!");
        elif(tmp[0] == "hidraw_acs_overrides_patch"):
            hidraw_acs_overrides_patch = int(tmp[1]);
            print("hidraw_acs_overrides_patch aktiv!");
        elif(tmp[0] == "ipv6_privacy"):
            ipv6_privacy = int(tmp[1]);
            print("ipv6_privacy aktiv!");
        elif(tmp[0] == "faketime"):
            faketime = tmp[1];
            if(faketime != ""):
                print("faketime aktiv!");
                print("faketime: " + faketime)
        elif(tmp[0] == "wine_32bit_speed_hak"):
            wine_32bit_speed_hak = int(tmp[1]);
            print("wine_32bit_speed_hak aktiv!");
        elif(tmp[0] == "read_only"):
            read_only = tmp[1];
            print("bearbeitung_Schutz aktiv!")
        elif(tmp[0] == "read_only_password"):
            read_only_password = tmp[1];
            print("bearbeitung_Schutz mit Pasword aktiv!")
        elif(tmp[0] == "sav_Version"):
            json_config_Verison = tmp[1];
        else:
            print("ERROR config file corrupt");
            print(tmp);
            exit(1);
        i = i +1;

    if(json_config_Verison.find("crypt") == -1):
        file_write_json(dirname + "/config_file_json", docker_user, gpu_render, disk_device_name, zugriff_auf_media, sav_home_docker_folder, share_folder_daten, share_folder1_aktiv, share_folder1, network_disable, steam_controller_bool, usb_sharing, usb_name, usb_hidraw_name, docker_build, maxmemory, maxcpus, network_host, portforwding, dbus_rw, pacman_cache, dns, ipv4, wireguard_fix, nosudo, run_in_background, ttyon, pacman_pakgage_install, docker_input, bluethoot_passthrough,
            hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, read_only, read_only_password);

    if(gpu_Render_check_is_int(gpu_render) == 0):
        gpu_render_2 = gpu_render;
        atmp = read_all_dri_prime_device();
        for i in range(len(atmp)):
            tmp = atmp[i].split(" (")[0];
            if(tmp == gpu_render):
                gpu_render_2 = str(i);
                break;
        if(gpu_Render_check_is_int(gpu_render_2) == 0):
            print("gpu not found! setze auf 0 gpu render!")
            gpu_render_2 = "0";
    else:
        gpu_render_2 = gpu_render;

    custom_command = "";
    optical_disk = read_scsi(disk_device_name);
    create_a_cdrom_mount_file_per_dev(optical_disk, docker_user, dirname);

    if(bluethoot_passthrough == 1):
        hidraw_acs_overrides_patch = 1;

    if(hidraw_acs_overrides_patch == 1):
        print("hidraw_acs_overrides_patch aktiv!");

    emptyfolder = dirname + "/xinput_tmp";

    if(basename == "command"):
        custom_command = sargs;
    if(basename == "command_root"):
        custom_command = sargs;
    if(basename == "build"):
        print("disable nosudo!")
        nosudo = 0;

    if(os.path.isfile(dirname+"/hidraw_acs_overrides_patch.py") == False):
        print("hidraw_acs_overrides_patch.py file not found!");
        exit(-1);
    if(os.path.isfile(dirname+"/chmod_check.py") == False):
        print("chmod_check.py file not found!");
        exit(-1);



    base_args = [
        "docker", "--privileged",
        "-e", "DRI_PRIME=" + gpu_render_2,
        "-e", "XDG_RUNTIME_DIR=" + os.environ["XDG_RUNTIME_DIR"],
        "-e", "DBUS_SESSION_BUS_ADDRESS=" + os.environ["DBUS_SESSION_BUS_ADDRESS"],
        "-e", "LANG=" + os.environ["LANG"],
        #"-e", "PWD=/home/" + docker_user,
        "-h", platform.node(),
        #"-v", "/dev/dri:/dev/dri",
        #"-v", "/dev/shm:/dev/shm",
        "--device", "/dev/vga_arbiter:/dev/vga_arbiter",
        "-v", "/etc/localtime:/etc/localtime:ro",
        #"-v", "/etc/machine-id:/etc/machine-id:ro",
        "-v", "/run/user/" + str(os.getuid()) + "/pulse:/run/user/" + str(os.getuid()) + "/pulse:ro",
        "-v", "/run/user/" + str(os.getuid()) + ":/run/user/" + str(os.getuid()) + ":rw",
        #"-v", "/dev/snd:/dev/snd",
        #"-v", "/tmp/.X11-unix:/tmp/.X11-unix:rw",
        "-v", "/var/run/dbus/system_bus_socket:/var/run/dbus/system_bus_socket:ro",
        #"-v", "/var/lib/dbus:/var/lib/dbus",
        "-v", dirname+"/pulse-client.conf:/etc/pulse/client.conf:ro",
        "-v", "/dev/loop0:/dev/loop0:ro",
        #"-v", dirname+"/hostname:/etc/hostname:ro",
        #"-v", dirname+"/mirrorlist:/etc/pacman.d/mirrorlist:ro",

        #archlinux locale gen fix
        ##"-v", "/etc/locale.conf:/etc/locale.conf:ro",
        ##"-v", "/etc/locale.gen:/etc/locale.gen:ro",
        #"-v", "/tmp/.X11-unix:/tmp/.X11-unix:rw",
        "--device", "/dev/fb0:/dev/fb0:rw",
        #"-v", "/dev/snd:/dev/snd",
        "--group-add", "video",
        "--security-opt=seccomp:unconfined",
        #"--group-add", "render",
        #"--group-add", "optical",
        #"--group-add", "input",
        #"--device", "/dev/snd",
        #"-v", "/etc/vconsole.conf:/etc/vconsole.conf:ro",
        #"-e", "KEYMAP=de-latin1-nodeadkeys",
        #"-v", "/dev/input/:/dev/input/:ro",
        "-v", dirname+"/chmod_check.py:/root/chmod_check.py:ro",
        "-v", dirname+"/hidraw_acs_overrides_patch.py:/root/hidraw_acs_overrides_patch.py:ro",
    ]

    base_args = device_folder_passthrough("/dev/snd", base_args);
    base_args = device_folder_passthrough("/dev/shm", base_args);
    base_args = device_folder_passthrough("/dev/dri", base_args);

    if(basename != "build"):
        base_args.append("--ipc=\"host\"");
        base_args.append("--shm-size=\"8G\"");
        pass

    if(ttyon == 1):
        print("ttyon aktive");
        print("Terminal on Gui off");
        #base_args.append("-t");
    if(os.path.isfile(dirname+"/machine-id") == True):
        print("found machine-id from fodler");
        base_args.append("-v");
        base_args.append(dirname+"/machine-id:/etc/machine-id:ro");
    else:
        print("found machine-id from /etc/ fodler");
        base_args.append("-v");
        base_args.append("/etc/machine-id:/etc/machine-id:ro");

    if(dbus_rw == 1):
        print("dbus_rw on");
        base_args.append("-v");
        base_args.append("/var/lib/dbus:/var/lib/dbus",);
        base_args.append("-v");
        base_args.append("/tmp/.X11-unix:/tmp/.X11-unix:rw");
        #base_args.append("-v");
        #base_args.append("/dev/snd:/dev/snd");
        base_args = device_folder_passthrough("/dev/snd", base_args);
    else:
        base_args.append("-v");
        base_args.append("/tmp/.X11-unix:/tmp/.X11-unix:ro");

    if(os.path.isfile(dirname+"/mirrorlist") == True):
        base_args.append("-v");
        base_args.append(dirname+"/mirrorlist:/etc/pacman.d/mirrorlist:ro");
        print("add pacman mirrolist");
    if(docker_input != ""):
        if(docker_input == "*"):
            base_args.append("-v");
            base_args.append("/dev/input/:/dev/input/:rw");
            print("xinput device all add");
        elif(docker_input == "block"):
            print("add block empty folder for xinput");
            base_args.append("-v");
            base_args.append(emptyfolder + ":"+ "/dev/input" + ":rw");
            base_args.append("-v");
            base_args.append(emptyfolder + ":"+ "/dev/input/event3" + ":rw");
            #out = add_input_device(docker_input);
        else:
            #print("add empty folder for xinput");
            base_args.append("-v");
            base_args.append(emptyfolder + ":"+ "/dev/input" + ":rw");
            out = add_input_device(docker_input);
            print("xinput device add");
            for tmp in out:
                tmp2 = os.path.realpath(tmp);
                base_args.append("-v");
                base_args.append(tmp2 + ":"+ tmp2 + ":ro");
                print(tmp);
                print(tmp2 + ":"+ tmp2 + ":ro");

    i = 0;
    for tmp in optical_disk[0]:
        base_args.append("--device");
        base_args.append(tmp);
    for tmp in optical_disk[1]:
        base_args.append("--device");
        base_args.append(tmp);

    if(zugriff_auf_media == 1):
        if(os.path.isdir("/run/media") == False):
            print("ERROR /run/media folder not found");
        else:
            base_args.append("-v");
            base_args.append("/run/media:/run/media:rw");
            print("acces allow from /run/media on");

    if(sav_home_docker_folder == 1):
        base_args.append("-v");
        base_args.append(dirname+"/home:/home/" + docker_user + ":rw");
        print("sav home folder");

    if(share_folder_daten == 1):
        base_args.append("-v");
        base_args.append(dirname+"/daten:/home/" + docker_user + "/daten:rw");
        base_args.append("-v");
        base_args.append(dirname+"/daten:/root" + "/daten:rw");
        print("share daten fodler");

    if(share_folder1_aktiv == 1):
        sharingfolders = share_folder1.split("^");
        if(True):
            for tmp in sharingfolders:
                if(len(tmp) >= 1 and tmp[0] != "/" and tmp.find(":") == -1):
                    if(os.path.isdir(dirname+"/"+tmp) == True):
                        base_args.append("-v");
                        base_args.append(dirname+"/"+tmp + ":" + "/home/" + docker_user  + "/" + tmp + ":rw");
                        base_args.append("-v");
                        base_args.append(dirname+"/"+tmp + ":" + "/root/" + tmp + ":rw");
                        print("share fodler " +dirname+"/"+tmp + ":" + "/home/" + docker_user + "/" + tmp + ":rw" + " aktive");
                        print("share fodler " +dirname+"/"+tmp + ":" + "/root/" + tmp + ":rw" + " aktive");
                    else:
                        print("ERROR share_folder1 folder not found : " + dirname+"/"+tmp);
                elif(tmp.find(":") == -1):
                    if(os.path.isdir(tmp) == False):
                        if(os.path.isdir(dirname+"/"+tmp) == True):
                            base_args.append("-v");
                            base_args.append(dirname+"/"+tmp + ":" + tmp + ":rw");
                            print("share fodler " + tmp + " aktive");
                        else:
                            base_args.append("-v");
                            base_args.append(tmp + ":" + tmp + ":rw");
                            print("share fodler " + tmp + " aktive");
                    else:
                        base_args.append("-v");
                        base_args.append(tmp + ":" + tmp + ":rw");
                        print("share fodler " + tmp + " aktive");
                else:
                    s1 = tmp.split(":")[0];
                    if(os.path.isdir(dirname+"/"+s1) == True):
                        base_args.append("-v");
                        base_args.append(dirname+"/"+tmp);
                        print("share fodler " + dirname+s1 + " aktive");
                    elif(os.path.isdir(s1) == True ):
                        base_args.append("-v");
                        base_args.append(tmp);
                        print("share fodler " + tmp + " aktive");
                    elif(os.path.isdir(dirname+"/"+s1) == False ):
                        if(os.path.isfile(dirname+"/"+s1) == False):
                            print("ERROR share_folder1 folder not found : " + dirname+"/"+s1);
                        else:
                            base_args.append("-v");
                            base_args.append(dirname+"/"+tmp);
                            print("share fodler " + tmp + " aktive");
                    else:
                        base_args.append("-v");
                        base_args.append(dirname+"/"+tmp);
                        print("share fodler " + tmp + " aktive");


    if(network_disable == 1):
        base_args.append("--network");
        base_args.append("none");
        print("Network disable");


    if(os.path.isfile(dirname+"/hostname") == True):
        base_args.append("-v");
        base_args.append(dirname+"/hostname:/etc/hostname:ro");


    if(usb_sharing == 1):
        base_args.append("-v");
        base_args.append("/dev/bus/:/dev/bus/:rw");
        base_args.append("-v");
        base_args.append("/dev/usb:/dev/usb:rw");
        pass;

    if(os.path.isdir(dirname+"/share") == True or os.path.islink(dirname+"/share") == True):
        print("sharing the share fodler on");
        base_args.append("-v");
        base_args.append(dirname+"/share:/home/" + docker_user + "/share:rw");
        base_args.append("-v");
        base_args.append(dirname+"/share:/root/share:rw");
    if(usb_sharing == 1):
        if(usb_name.find("^") == -1):
            print("usb_sharing enabled");
            print(usb_name);
            print(usb_hidraw_name);
            usb = usb_pasthrough(usb_name);
            usbdir = usb[0];
            usbdev = usb[1];
        else:
            usbdir = [];
            usbdev = [];
            s1 = usb_name.split("^");
            for tmp in s1:
                print("usb_sharing enabled");
                print(tmp);
                #print(usb_hidraw_name);
                usb = usb_pasthrough(tmp);
                usbdir = array_add_aarray(usbdir, usb[0]);
                usbdev = array_add_aarray(usbdev, usb[1]);

        print(usb);
        if(len(usbdir) != 0):
            i = 0;
            while True:
                if(i >= len(usbdir)):
                    break;
                if(os.path.isdir("/dev/bus/usb/" +usbdir[i]) == True):
                    if(check_device_isopen("/dev/bus/usb/" +usbdir[i] + "/" + usbdev[i]) == 1):
                        base_args.append("-v");
                        base_args.append("/dev/bus/usb/" +usbdir[i] + "/" + usbdev[i]+ ":" + "/dev/bus/usb/" +usbdir[i] + "/" + usbdev[i]);
                    else:
                        print("ERROR usb dev file not found!");
                        print("/dev/bus/usb/" +usbdir[i] + "/" + usbdev[i]);
                        break;
                else:
                    print("ERROR usb dev dir not found!");
                    print("/dev/bus/usb/" +usbdir[i]);
                    break;
                i = i +1;
        else:
            print("usb_name: \"" + usb_name + "\" not found");

        if(usb_hidraw_name.find("^") == -1):
            dev = read_hidraw_device(usb_hidraw_name);
            if(len(dev) != 0):
                for tmp2 in dev:
                    base_args.append("--device");
                    base_args.append(tmp2);
            else:
                print("usb_hidraw_name: \"" + usb_hidraw_name + "\" not found");
        else:
            s1 = usb_hidraw_name.split("^");
            for tmp in s1:
                dev = read_hidraw_device(tmp);
                if(len(dev) != 0):
                    for tmp2 in dev:
                        base_args.append("--device");
                        base_args.append(tmp2);
                else:
                    print("usb_hidraw_name: \"" + tmp + "\" not found");


    if(steam_controller_bool == 1):
        if(usb_sharing != 1 and usb_name != "" and usb_hidraw_name != ""):
            print("ERRROR enable usb_sharing and usb_name and usb_hidraw_name setzen");
        inputs = read_steam_Controller();
        i = 0;
        while True:
            if(i >= len(inputs)):
                break;
            base_args.append("--device");
            #base_args.append(inputs[i] + ":" + inputs[i]);
            base_args.append(inputs[i]);
            i = i +1;
        base_args.append("-v");
        base_args.append("/run/dbus:/run/dbus");

    if(maxmemory != -1):
        print("set maxmemory to", maxmemory);
        base_args.append("--memory="+str(maxmemory) + "MB");
    if(maxcpus != -1):
        print("set cpus to", maxcpus);
        base_args.append("--cpus="+str(maxcpus));
    if(network_host != "" and network_host != "0" and network_disable == 0):
        print("network_host aktive");
        base_args.append("--net="+network_host);
    if(portforwding != ""):
        print("portforwding aktive");
        base_args.append("-p")
        base_args.append(portforwding);
        #-p 8080:80
    if(pacman_cache != "" and nosudo == 0):
        print("pacman_cache aktive");
        base_args.append("-v");
        base_args.append(pacman_cache+":"+"/var/cache/pacman/pkg:ro");
        base_args.append("-v");
        base_args.append(pacman_cache+":"+"/mnt/pacman_cache_rw");
        system("sudo chmod -R 777 " + pacman_cache);
        user = home = os.environ['USER'];
        system("sudo chown -R "+ user + ":users " + pacman_cache);
    dirname_tmp = "";
    if(docker_build != "folder_name"):
        dirname_tmp = docker_build;
    else:
        dirname_tmp = os.path.split(dirname)[-1];

    if(dns != ""):
        dns_ = dns.split("^");
        if(len(dns_) >= 1):
            for tmp in dns_:
                base_args.append("--dns");
                base_args.append(tmp);
                print("DNS Server wird auf", dns, "gesezt!");
        else:
            base_args.append("--dns");
            base_args.append(dns);
            print("DNS Server wird auf", dns, "gesezt!");

    print(ipv4)
    if(ipv4 != ""):
        print("static ip gestzt auf " + ipv4);
        base_args.append("--ip");
        base_args.append(ipv4);
    #if(os.path.isfile("/etc/resolv.conf") == True):
    #    base_args.append("-v");
    #    base_args.append("/etc/resolv.conf:/etc/resolv.conf:ro");
    #    print("add /etc/resolv.conf to docker container!");
    if(ipv6_privacy == 1):
        print("Ipv6 privacy on!")

    if(wireguard_fix == 1):
        #wire guard patch
        base_args.append("--cap-add");
        base_args.append("net_admin");
        base_args.append("--cap-add");
        base_args.append("sys_module");
        base_args.append("-v");
        base_args.append("/usr/lib/modules:/usr/lib/modules:ro");
        base_args.append("--sysctl");
        base_args.append("net.ipv6.conf.all.disable_ipv6=0");
        base_args.append("--sysctl");
        base_args.append("net.ipv4.conf.all.src_valid_mark=1");
        base_args.append("-v");
        base_args.append("/sys/fs/cgroup:/sys/fs/cgroup:ro");
        #unboud fix 0.1a
        base_args.append("--ulimit nofile=5000:5000");
        print("wireguard_fix aktive!");

    if(run_in_background == 1):
        print("run_in_background aktiv!");
        base_args.append("-d");

    if(os.path.isfile("/etc/vconsole.conf") == True):
        base_args.append("-v");
        base_args.append("/etc/vconsole.conf:/etc/vconsole.conf:ro");
        base_args.append("-v");
        base_args.append("/etc/locale.conf:/etc/locale.conf:ro");
        base_args.append("-v");
        if(os.path.isfile("locale.gen") == True):
            base_args.append(dirname + "/locale.gen:/etc/locale.gen:ro");
        else:
            base_args.append("/etc/locale.gen:/etc/locale.gen:ro");
    else:
        print("ERRRO not found /etc/vconsole.conf!");

    if(os.path.isfile(dirname + "/" + "pipe.tmp") == False):
        f1 = open(dirname + "/" + "pipe.tmp", "w");
        f1.close();

    base_args.append("-v");
    base_args.append(dirname + "/" + "pipe.tmp:/tmp/pipe.tmp:rw");

    if(True):
        tmp1 = check_env("WAYLAND_DISPLAY");
        if(tmp1 != -1):
            base_args.append("-e");
            base_args.append("WAYLAND_DISPLAY:" + tmp1);
            base_args.append("-e");
            base_args.append("DISPLAY=" + os.environ["DISPLAY"]);
            print("WAYLAND aktiv!")
        else:
            print("XORG aktiv!")
            base_args.append("-e");
            base_args.append("DISPLAY=" + os.environ["DISPLAY"]);
            base_args.append("-v");
            base_args.append( os.environ["XAUTHORITY"] + ":/home/" + docker_user + "/.Xauthority:rw");
            base_args.append("-v");
            base_args.append(os.environ["XAUTHORITY"] + ":/root/" + "/.Xauthority:rw");
            #https://unix.stackexchange.com/questions/330366/how-can-i-run-a-graphical-application-in-a-container-under-wayland

    #if(basename != "build" and os.path.isdir("/usr/share/locale") == True):
    #    base_args.append("-v");
    #    base_args.append("/usr/share/locale:/usr/share/locale:ro");
    #    base_args.append("-v");
    #    base_args.append("/usr/lib/locale:/usr/lib/locale:ro");
    #else:
    #    print("ERROR not found /usr/share/locale on host system!");

    if(True):
        base_args.append("-v");
        base_args.append(dirname + "/user_patched.bash:/etc/user_patched.bash:ro");
        base_args.append("-v");
        base_args.append(dirname + "/user_patched2.bash:/etc/user_patched2.bash:ro");
        if(basename == "command"):
            patching_user(docker_user, "su " + docker_user + " - -c ",  custom_command, str(os.getuid()), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak);
        elif(basename == "command_root"):
            patching_user(docker_user, "",  custom_command, str(os.getuid()), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak);
        elif(basename == "login"):
            patching_user(docker_user, "su "+docker_user , "bash", str(os.getuid()), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak);
        elif(basename == "login_root"):
            patching_user(docker_user, "su", "su", str(os.getuid()), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak);
        elif(basename == "openra-ra"):
            patching_user(docker_user, "su " + docker_user + " - -c ", "openra-ra", str(os.getuid()), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak);
        elif(basename == "firefox"):
            patching_user(docker_user, "su " + docker_user + " - -c ", "firefox", str(os.getuid()), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak);
        elif(basename == "firefox"):
            patching_user(docker_user, "su " + docker_user + " - -c ", "firefox", str(os.getuid()), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak);
        elif(basename == "firefox"):
            patching_user(docker_user, "su " + docker_user + " - -c ", "firefox", str(os.getuid()), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak);
        elif(basename == "build"):
            pass;
        elif(basename == "run"):
            pass;
        elif(basename == "edit_config"):
            pass
        else:
            print("Command not found!");
            exit();
    #base_args.append(os.path.split(dirname)[-1]);

    build_args = filter_docker_build(base_args);
    print(build_args)
    base_args.append(dirname_tmp);
    if(basename == "edit_config"):
        start_json_edit_gui(dirname, docker_user, gpu_render, disk_device_name, zugriff_auf_media, sav_home_docker_folder, share_folder_daten,
                            share_folder1_aktiv, share_folder1, network_disable, steam_controller_bool, usb_sharing, usb_name, usb_hidraw_name,
                            docker_build, docker_input, maxmemory, maxcpus, network_host, portforwding, dbus_rw, pacman_cache, dns, ipv4,
                            wireguard_fix, nosudo, run_in_background, ttyon, pacman_pakgage_install, bluethoot_passthrough,
                            hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, read_only, read_only_password);

    if(ttyon == 0):
        #gui aktiv
        args = {
            #"build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
            "build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
            "run": [base_args[0], "run"] + (base_args[1:]),
            "login": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "login_root": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "openra-ra": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "firefox": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "command": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "command_root": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
        }
        if __name__ == "__main__":
            print(args[basename]);
            #cmd = subprocessvhba-module-dkms.check_output(base_args[0] + , shell=True).decode().split("\n");
            #os.s(base_args[0], args[basename])
            cmd = args_array_to_str(args[basename]);
            if(basename == "build"):
                os.chdir(os.path.join(dirname , "archlinux_std_docker"));
                os.system("./build");
                os.chdir(dirname);
            elif(basename == "login" or basename == "login_root" ):
                os.system(cmd);
                print(cmd)
            else:
                os.system(cmd);
                print(cmd)
            #print(cmd)
        if(basename == "build" and pacman_cache != ""):
            fertigfile = os.path.join(pacman_cache, "fertig");
            if(os.path.isfile(fertigfile) == True):
                os.remove(fertigfile);
            print("starting mod")
            start_thread_wait("bash install.bash");
            while True:
                if(start_thread_wait("./command_root 'pacman -Sy archlinux-keyring --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --downloadonly --cachedir /mnt/pacman_cache_rw/ && exit'") == 0):
                    break;
            start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
            #start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
            time.sleep(30);
            wait_build_fertig(fertigfile, dirname_tmp);
            dockerid = read_docker_ps(dirname_tmp);
            tmp = "";
            if(dockerid != ""):
                print("sav docker image")
                print(dockerid);
                print(tmp);
                cmd = "docker commit " + dockerid + " " + dirname_tmp;
                os.system(cmd);
                print("docker save!");
                exit();
            else:
                print("ERROR docker id not found");
                exit(-1);
            thread_wait_is_exit();
        else:
            print("ERROR pacman cache is empty in config file!");
    elif(ttyon == 1):
        #ttyon 1 #gui off terminal on
        print("Terminal on!")
        args = {
            #"build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
            "build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
            "run": [base_args[0], "run"] + (base_args[1:]),
            "login": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "login_root": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "openra-ra": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "firefox": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "command": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "command_root": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
        }
        if __name__ == "__main__":
            print(args[basename]);
            #cmd = subprocessvhba-module-dkms.check_output(base_args[0] + , shell=True).decode().split("\n");
            #os.s(base_args[0], args[basename])
            cmd = args_array_to_str(args[basename]);
            if(basename == "build"):
                os.chdir(os.path.join(dirname , "archlinux_std_docker"));
                os.system("./build");
                os.chdir(dirname);
            elif(basename == "login" or basename == "login_root" ):
                os.system(cmd);
                print(cmd)
            else:
                os.system(cmd);
                print(cmd)
            #print(cmd)
        if(basename == "build" and pacman_cache != ""):
            fertigfile = os.path.join(pacman_cache, "fertig");
            if(os.path.isfile(fertigfile) == True):
                os.remove(fertigfile);
            print("starting mod")
            start_thread_wait("bash install.bash");
            print("downloading pacman data..")
            while True:
                if(start_thread_wait("./command_root 'pacman -Sy archlinux-keyring --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --downloadonly --cachedir /mnt/pacman_cache_rw/ && exit'") == 0):
                    break;
            start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --needed  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
            #start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
            #start_thread
            time.sleep(30);
            wait_build_fertig(fertigfile, dirname_tmp);
            dockerid = read_docker_ps(dirname_tmp);
            tmp = "";
            if(dockerid != ""):
                print("sav docker image")
                print(dockerid);
                print(tmp);
                cmd = "docker commit " + dockerid + " " + dirname_tmp;
                os.system(cmd);
                print("docker save!");
                exit();
            else:
                print("ERROR docker id not found");
                exit(-1);
            thread_wait_is_exit();
    else:
        #ttyon 2 #gui off terminal on docker checkpoit on
        build_args.append("-d");
        build_args.append("busybox");
        print("Terminal on!")
        args = {
            #"build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
            "build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
            "run": [base_args[0], "run", "-i"] + (base_args[1:]),
            "login": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "login_root": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "openra-ra": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "firefox": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "command": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
            "command_root": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/user_patched.bash"]),
        }
        if __name__ == "__main__":
            print(args[basename]);
            #cmd = subprocessvhba-module-dkms.check_output(base_args[0] + , shell=True).decode().split("\n");
            #os.s(base_args[0], args[basename])
            cmd = args_array_to_str(args[basename]);
            if(basename == "build"):
                os.chdir(os.path.join(dirname , "archlinux_std_docker"));
                os.system("./build");
                os.chdir(dirname);
            elif(basename == "login" or basename == "login_root" ):
                os.system(cmd);
                print(cmd)
            else:
                os.system(cmd);
                print(cmd)
            #print(cmd)
        if(basename == "build" and pacman_cache != ""):
            fertigfile = os.path.join(pacman_cache, "fertig");
            if(os.path.isfile(fertigfile) == True):
                os.remove(fertigfile);
            print("starting mod")
            start_thread_wait("bash install.bash");
            print("downloading pacman data..")
            while True:
                if(start_thread_wait("./command_root 'pacman -Sy archlinux-keyring --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --downloadonly --cachedir /mnt/pacman_cache_rw/ && exit'") == 0):
                    break;
            start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --needed  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
            #start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
            #start_thread
            time.sleep(30);
            wait_build_fertig(fertigfile, dirname_tmp);
            dockerid = read_docker_ps(dirname_tmp);
            tmp = "";
            if(dockerid != ""):
                print("sav docker image")
                print(dockerid);
                print(tmp);
                cmd = "docker commit " + dockerid + " " + dirname_tmp;
                os.system(cmd);
                print("docker save!");
                exit();
            else:
                print("ERROR docker id not found");
                exit(-1);
            thread_wait_is_exit();
        else:
            print("ERROR pacman cache is empty in config file!");


    return 0;

main();
exit();
