#!/usr/bin/env python3
#Copyright (C) 2022  vfio_experte
#This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
#This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#You should have received a copy of the GNU General Public License along with this program; if not, see <http://www.gnu.org/licenses/>.
#this is a fork from https://github.com/kritzsie/steam-on-docker
#start project 04.02.2021


#last edit 06.12.2022

version = "v0.32c"
DEBUG_MODE = 1; #0 off, 1 on
appname_build = "vfio_experte_docker_contianer_gaming_app"
#v0.32b Xorg DISAPLAY crash fix 0.2a gamescope crash fix
#v0.31e_hotfix_58 steam docker audio fix 0.2a
#v0.31e_hotfix_56 lxc build fix 0.1a
#"v0.31e_hotfix_55 add new config oprtions amdgpu_nohyperz,amdgpu_pswave32,amdgpu_nv_ms,amdgpu_vrs
#v0.31e_hotfix_54 nvidia dlss fix 0.2a
#v0.31e_hotfix_53 nvidia dlss and wine esync_fsync
#v0.31e_hotfix_52 fix cdromlib 0.3a
#v0.31e_hotfix_51 acces denied after create a home and daten folder fix 0.1
#v0.31e_hotfix_50 userid 1001 crash fix 0.1b
#v0.31e_hotfix_48 pacman eroor code reading 0.1a apha
#v0.31e_hotfix_47 autoatisch "./killall -killall" 0.1a
#v0.31e_hotfix_46 usb_lib.py crash by muti start fix 0.1b
#v0.31e_hotfix_45 sudo sicherheits patch 0.1a
#v0.31e_hotfix_44 docker build fix 0.1a
#v0.31e_hotfix_43 neu fuktion ipv6 addr dsiable 0.1a
#v0.31e_hotfix_42 lxc mac patch fix 0.1a and json gui 0.4f hotfix 3 lxc hotfix 42 network bridge question by swit from lxc to docker fix 0.1a
#v0.31e_hotfix_41 add mac addr for docker 0.1a
#v0.31e_hotfix_39 dbus lxc continer fix 0.1a
#v0.31e_hotfix_38 lxc vulkan device name to singel card fix 0.1a
#v0.31e_hotfix_37 XAUTHORITY fiel mnot exist in system_only2 command run fix 0.1a
#v0.31e_hotfix_36 keyboard no input user acces denied fi x0.1a
#v0.31e_hotfix_35 mount path in lxc contianer fix 0.1a
#v0.31e_hotfix_34 faile to start fix 0.1a
#v0.31e_hotfix_32 beta 1 lxc /etc mount fix 0.1a and /etc/localtime found is a file fix 0.1a
#v0.31e_hotfix_27 beta radmon mac addr by lxc fix 0.1a
#v0.31e_hotfix_26 empty user id fix 0.1a
#0.1d hotfix 25 lxc , 0.4f hotfix 3 lxc hotfix 25 lxc fix muti gpu to singel gpu in vm convert fix 0.1a
#v0.31e_hotfix_24 build error free sapce pacman fix 0.2a
#v0.31e_hotfix_19 cdrom not work
#v0.31e_hotfix_17 unset container fix 0.1a
#v0.31e_hotfix_16 gamescope fix 0.1a
#v0.31e_hotfix_15 dbus_rw = 1 fix 0.1a, gamescope fix 0.1a
#v0.31e_hotfix_13 lxc network bridge auto create 0.2a
#v0.31e_hotfix_12 lxc killall und coanitner copy in redaon lxc mode 0.2a
#v0.31e_hotfix_8 manger work 0.1a
#0.31e_hotfix_7 lxc auto install 0.1c
#v0.31e_hotfix_3 build hotfix lxc
#v0.31d" 0.1d steam fix 0.1a
#v0.31c 0.4e docker system combobox fix 0.1a
#v0.31b 0.1c lxc.yp moudle bug fix 0.1c
#docker_system = 0;#1 docker 0 lxc
#lxc_readonly = 1;#1 root readonly
#lxc staticip wird benotigt und cd dns server angaber
#dns und mac
#v0.31b joson gui new desgine 0.2a
#v0.31b dbus_rw remote display files from /tmp/.X11-unix/X0 fixed 0.1b
#0.31a more as one netwrok inten faces fix 0.1 beta 1
#v0.30k_hotfix9 default network_disable on fix 01.a
#v0.30k_hotfix6 mesa-utils use in docker conatiner fix 0.1a
#v0.30k_hotfix3 ICE default IO error handler doing an exit(), pid = 82334, errno = 32 fix 0.1b
#v0.30k add new command killall 0.1a
#v0.3j hotfix 4 system_only command 0.1d
#v0.30g 0.4a_hotfix_5 glxinfo run in archlinux docker coantiner
#v0.30f new manager_gui add create a new vm 0.1b
#v0.30e raytrasing and smart_acces_meomory fix 0.1a
#v0.30d josn file 0.3l_hotfix_2 0.1a
#v0.30c add freesync and vsync 0.1a
#v0.30b add dxvk.conf_sam 0.1a
#v0.29g add new command steam_proton_run_without_steam, mango_hud, vkbasalt 0.1a
#0.29f vulkan_index 01.b
#v0.29e optional_array and smart_acces_meomory add
#v0.29d debug_mode 0.1a
#v0.29b manager_gui command and gui 0.1a
#v0.29a wine_fsr
#0.28t mesa 3d amd gpu raytrasing support
#0.28r json gui 0.3f_6  virgl hot fix 0.1a
#0.28q gpu redner not loading by encrypt file 1.0 #json file 0.3f_3
#0.28o pacman cahche empty
#0.28o wayland support 0.1a
#0.28n build failed fix 0.1a
#0.28m add DRI_PRIME reading fix 0.2a #create_links 0.1a
#0.28k #0.3f_3 json_edit_gui add a scrollbar
#0.28i patching_lib .3d add new file /etc/cmd/user_patched2.bash and fix faketime 0.1a
#json_file.py loading bug fix 1 + json gui rechtscheibung fix 1
#0.28g docker_build standard fix 0.1a
#0.28f bearbeitung schutz 0.1a mit Fernet
#0.28e 32bit speed hak "sysctl -w abi.vsyscall32=0"

print(version);

import platform
import os
import sys
import string
import subprocess
import time

#from PyQt5 import QtWidgets
#from PyQt5 import QtGui
import math

import json

from Code.Json.json_file import *
from Code.Path.path_lib import *
from Code.Patching.patching_lib import *
from Code.Usb.usb_lib import *
from Code.Cd_Rom.cdrom_lib import *
from Code.Gui.json_edit_gui.json_edit_gui import *
from Code.Xinput.xinput_lib import *
from Code.Bluethooth.bluethooth_lib import *
from Code.Crypt.rsa_lib import *
from Code.Gui.manager_gui.manager_gui import *
from Code.Lxc.lxc import *


jason_data = {};

#app = QtWidgets.QApplication(sys.argv)

pacman_downloads = 3;

pacman_pkgage_install = "unbound qt5pas teamspeak3 python-ntlm-auth  python-requests-ntlm perl-ntlm python-ntlm-auth python-requests-ntlm  lutris python-beaker python-mako valgrind llvm lib32-llvm meson vulkan-swrast net-tools wireguard-tools nautilus shared-mime-info gdk-pixbuf2 thunderbird-i18n-de python-pyqt5  gnu-netcat opendoas retroarch-assets-glui retroarch-assets-ozone ninja ccache glm openvr yad archlinux-keyring base base-devel xf86-video-ati xf86-video-amdgpu  xorg xorg-server xorg-xinit mesa-demos vulkan-tools  vulkan-mesa-layers vulkan-radeon  vulkan-icd-loader pulseaudio alsa-tools alsa-utils pulseaudio-alsa pavucontrol  wine lib32-mpg123 openra winetricks openal firefox-i18n-de xfce4-terminal openvpn dotnet-runtime dotnet-sdk thunar ntfs-3g exfat-utils boost mpv desmume mgba-qt mgba-sdl xfce4 xfce4-goodies blender opencl-mesa  gst-plugins-ugly  qt5-webengine qt5-base qt5-multimedia qt5-tools fmt libxkbcommon-x11 sdl2 desktop-file-utils shared-mime-info nlohmann-json boost catch2 cmake git  nano adriconf   qt5-webglplugin qt5-webkit qt5-websockets qt5-webview  veracrypt desmume libretro-desmume nano p7zip snes9x retroarch libretro-mesen  mgba-qt python-pyqt5 mkvtoolnix-gui k3b qt5 sndio rkhunter qutebrowser hexedit youtube-dl vlc lib32-libpulse lib32-alsa-plugins hexedit qutebrowser youtube-dl obs-studio cdemu-client  cdemu-daemon vhba-module-dkms  virtualbox blender  gimp gimp-help-de   nfs-utils rsync subversion qemu cdrtools dolphin-emu lib32-mesa-vdpau mesa-vdpau  lib32-vulkan-radeon vulkan-radeon lib32-libva-mesa-driver libva-mesa-driver exfat-utils  python3 python-pip   python2-pip  python2 python-lz4 python2-apipkg python-lz4 python python-setuptools python-pip gphoto2 gvfs-gphoto2 libgphoto2  mono  wine-mono wine_gecko kvantum-qt5   qtcreator  falkon glfw-x11  git cmake  gcc clang htop shotcut archiso vulkan-headers vulkan-tools vulkan-extra-layers gimp-nufraw xdotool xorg-xinput gnu-netcat   gimp-help-de opencl-mesa  firefox-i18n-de vkd3d lib32-vkd3d  gparted libreoffice-still-de  inkscape  partclone pigz gedit pkgstats scons python-pyusb clamav clamtk  cura encfs playonlinux cura encfs steam xmlto docbook-xsl kmod inetutils bc git libelf steam-native-runtime xreader rawtherapee  nautilus minetest-server minetest";



home = "";
home = os.environ['HOME'];
home_fodler_daten = os.path.join(home, "." + appname_build);
dxvk_config_sam_on = os.path.join(home_fodler_daten, "dxvk_sam_on.conf");
dxvk_config_pulse = os.path.join(home_fodler_daten, "pulse-client.conf");
dxvk_config_chmod = os.path.join(home_fodler_daten, "chmod_check.py");
dxvk_config_hidraw = os.path.join(home_fodler_daten, "hidraw_acs_overrides_patch.py");
config_file = ".config";
config_file_json = "config_file_json";


#tmpfile = "/tmp/lsscsi1i3u45hz835z8345z3-384534875z3485z487";


#lsusb_temp_file = "/tmp/873264832654893775963457967hsdifhreufgdurbgfkuseb"

set_DEBUG_MODE_jsongui(DEBUG_MODE);
manager_gui_set_veriable(home, home_fodler_daten, dxvk_config_sam_on, dxvk_config_pulse, dxvk_config_chmod, dxvk_config_hidraw, config_file, config_file_json);

def brechen_config(name, value):
    return [name, value]

def system(cmd):
    try:
        output = subprocess.check_output(cmd, shell=True).decode().split("\n");
        return output;
    except subprocess.CalledProcessError:
        return "";
    except FileNotFoundError:
        return "";

devices = read_steam_Controller();


def filter_docker_build(cmdarray):
    i = 0;
    out = [];
    while True:
        if(i >= len(cmdarray)):
            break;
        tmp = cmdarray[i];
        if(tmp == "--privileged"):
            i = i +1;
            continue;
        elif(tmp == "-e"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "-v"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "--group-add"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "--device"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "-h"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "--mac-address"):
            i = i + 1;
            i = i +1;
            continue;
        elif(tmp == "--security-opt=seccomp:unconfined"):
            i = i + 1;
            continue;

        else:
            out.append(tmp);
        i = i +1;
    return out;


def read_docker_ps(suche):
    try:
        cmd = subprocess.check_output("docker ps ", shell=True).decode().split("\n");
        for tmp in cmd:
            if(tmp.split()[0] == "CONTAINER"):
                continue;
            elif(tmp.split()[1] == suche):
                return tmp.split()[0];
        return "";
    except subprocess.CalledProcessError:
        return "";
    except FileNotFoundError:
        return "";
    except IndexError:
        return "";

def args_array_to_str(array):
    s1 = "";
    for tmp in array:
        s1 = s1 + tmp + " ";
    return s1;

def wait_build_fertig(sfile, dirname_tmp):
    dockerid = read_docker_ps(dirname_tmp);
    if(os.path.isfile(sfile) == True):
        os.remove(sfile);
    while True:
        id = read_docker_ps(dirname_tmp);
        if(id != dockerid):
            print("ERROR docker coantiner is exit can not svae it!");
            exit();
        if(os.path.isfile(sfile) == True):
            os.remove(sfile);
            break;
    return 0;

import threading

class cmd_thread(threading.Thread):
    def __init__(self):
        super(cmd_thread, self).__init__()
        self.total=0
    def set(self, cmd):
        self.cmd = cmd;
        self.exit = 0;
        return 0;
    def run(self):
        #system(self.cmd);
        #cmd = subprocess.check_output(self.cmd, shell=True).decode();
        os.system(self.cmd);
        #print(cmd);
        self.exit = 1;
    def exit(self):
        return self.exit;

thread = cmd_thread();

def chek_eroor_found(array):
    for tmp in array:
        if(tmp.find("error: target not found:") != -1):
            print("pacman error: " + tmp);
            exit(-1);
    return 0;

def start_thread_wait(cmd):
    out = system(cmd);
    for tmp in out:
        tmp2 = tmp.split("EXITCODE--EXITCODE ");
        if(len(tmp2) >= 2):
            if(int(tmp2[1][0]) != 0):
                chek_eroor_found(out);
                print(out);
            return int(tmp2[1][0]);
    if(out == ""):
        return 1;
    return 0;

def start_thread(cmd):
    thread.set(cmd);
    thread.start();
    return 0;

def thread_wait_is_exit():
    thread.join();
    return 0;

def array_add_aarray(array1, addarraay):
    for tmp in addarraay:
        array1.append(tmp);
    return array1;

def read_args():
    b1 = 0;
    i = 1;
    s1 = "";
    while True:
        if(i >= len(sys.argv)):
            break;
        s2 = sys.argv[i];
        if(s2.find("\\n") != -1):
            a1 = s2.split("\\n");
            for tmp in a1:
                if(i != 1 and tmp.find(" ") != -1):
                    s1 = s1 + " '" + tmp + "' \n";
                else:
                    s1 = s1 + " " + tmp + " \n";

        elif(i != 1 and s2.find(" ") != -1):
            s1 = s1 + " '" + s2 + "' ";
        else:
            s1 = s1 + " " + s2 + " ";

        i = i +1;
    print("read_args: ", s1);
    return s1;

def gpu_Render_check_is_int(gpu_render):
    try:
        i = int(gpu_render);
        return 1;
    except ValueError:
        return 0;


def create_links():
    os.system("ln -sf build login_root")
    os.system("ln -sf build login")
    os.system("ln -sf build run")
    os.system("ln -sf build openra-ra")
    os.system("ln -sf build firefox")
    os.system("ln -sf build command")
    os.system("ln -sf build system_only")
    os.system("ln -sf build system_only2")
    os.system("ln -sf build system_only3")
    os.system("ln -sf build command_root")
    os.system("ln -sf build command_root_lxc")
    os.system("ln -sf build killall")
    os.system("ln -sf build edit_config")
    os.system("ln -sf build manager")
    os.system("chmod +x build");
    os.system("chmod +x chmod_check.py");
    os.system("chmod +x hidraw_acs_overrides_patch.py");
    return 0;

def check_env(s1):
    try:
        s2 = os.environ[s1];
        return s2;
    except KeyError:
        return -1;


def suche_vulkandevice(vkdevicename):
    if(basename == "system_only" or basename == "system_only2" or basename == "build"):
        return 0;
    system("./system_only2 'MESA_VK_DEVICE_SELECT=\"list\" vkcube 2>/etc/tmp/pipe.tmp'");
    f1 = open("pipe.tmp", "r");
    f1.seek(0, 2);
    size = f1.tell();
    f1.seek(0, 0);
    s1 = f1.read(size);
    f1.close();
    #print(s1);
    s2 = s1.split("\n");
    #print(s2)
    b1 = 0;
    for tmp in s2:
        s3 = tmp.split();
        if(b1 == 0):
            if(len(s3) >= 2):
                if(s3[0] == "selectable"):
                    if(s3[1] == "devices:"):
                        b1 = 1;
                        print("b1 = 1")
        elif(b1 == 1):
            if(len(s3) >= 6):
                device_name = s3[5].split("\"")[0];
                device_id = s3[2];
                if(device_name == vkdevicename):
                    return device_id;
                if(device_name.upper() == vkdevicename):
                    return device_id;
                if(device_name.lower() == vkdevicename):
                    return device_id;
    return 0;

def read_users_name():
    out = system("users");
    print(out[0])
    return out[0];

def create_a_new_home_data_fodler(basename):
    if(os.path.isdir(home_fodler_daten) == False):
        os.system("mkdir -p \"" + home_fodler_daten + "\"");
        os.system("sudo chmod -R  777 \"" + home_fodler_daten + "\"");
        os.system("sudo chown -R " + read_users_name() + ":users  \"" + home_fodler_daten + "\"");
    if(basename != "manager"):
        os.system("cp \"" + dxvk_config_sam_on + "\" dxvk_sam_on.conf" );
        os.system("cp \"" + dxvk_config_chmod + "\" chmod_check.py " );
        os.system("cp \"" + dxvk_config_hidraw + "\" hidraw_acs_overrides_patch.py" );
        os.system("cp \"" + dxvk_config_pulse + "\" pulse-client.conf" );
    else:
        #Manager start
        os.system("cp dxvk_sam_on.conf \"" + dxvk_config_sam_on + "\"" );
        os.system("cp chmod_check.py \"" + dxvk_config_chmod + "\"" );
        os.system("cp hidraw_acs_overrides_patch.py \"" + dxvk_config_hidraw + "\"" );
        os.system("cp pulse-client.conf \"" + dxvk_config_pulse + "\"" );
    return 0;

def read_docker_ps_all_continer_runing():
    out = [];
    try:
        cmd = subprocess.check_output("docker ps ", shell=True).decode().split("\n")[1::];
        for tmp in cmd:
            out.append(tmp.split()[0]);
        return out;
    except subprocess.CalledProcessError:
        return out;
    except FileNotFoundError:
        return out;
    except IndexError:
        return out;

def docker_stop_all():
    ids = read_docker_ps_all_continer_runing();
    s1 = "docker stop ";
    for tmp in ids:
        s1 = s1 + " " + tmp;
    print(s1)
    os.system(s1);
    return 0;

def docker_kill_all():
    ids = read_docker_ps_all_continer_runing();
    s1 = "docker kill ";
    for tmp in ids:
        s1 = s1 + " " + tmp;
    print(s1)
    os.system(s1);
    return 0;

def docker_killall(docker_build, auto):
    if(auto == 0):
        i1 = input("killall docker coantiner? y,n")
        if(i1 == "y" or i1 == "Y"):
            docker_stop_all();
            docker_kill_all();
        i1 = input("killall und remove lxc coantiner? y,n")
        if(i1 == "y" or i1 == "Y"):
            lxc_remove_all_vms(docker_build);
        return 0;
    else:
        docker_stop_all();
        docker_kill_all();
        lxc_remove_all_vms(docker_build);
        return 0;



def pci_ide_to_drmcard_id(pciid):
    pci = pciid.split(":")
    amdeviceid = subprocess.check_output("cat < /sys/class/drm/card0/device/driver/0000\:" + pci[0] + "\:" +pci[1] + "/device", shell=True).decode().split();
    #print(amdeviceid);
    return amdeviceid;

def pci_ids_to_device_name( pciid):
        amdeviceid = subprocess.check_output("lspci -k  -s " + pciid, shell=True).decode();
        s1 = amdeviceid.split("VGA compatible controller: ");
        s2 = s1[1].split("\n");
        s3 = s2[0].split("\t")
        #print(s3);
        return s3[0];

def check_device_id_dound( deviceid):
        i = 0;
        while True:
            if(i > 16):
                break;
            try:
                amdeviceid = subprocess.check_output("cat < /sys/class/drm/card" + str(i) + "/device/device", shell=True).decode().split();
                #print(amdeviceid);
                #print(deviceid)
                if(amdeviceid == deviceid):
                    return i;
            except subprocess.CalledProcessError:
                break;
            i = i +1;
        return -1;

def amd_gup_pci_ids():
        amd_pci_ids = subprocess.check_output("lspci | grep -E \"^.*(VGA|Display).*\[AMD\/ATI\].*$\" | grep -Eo \"^([0-9a-fA-F]+:[0-9a-fA-F]+.[0-9a-fA-F])\"", shell=True).decode().split()
        #amd_pci_ids = subprocess.check_output("lspci | grep -E \"^.*(VGA|Display).*\[AMD\/ATI\].*$\" ", shell=True).decode().split()
        #info = [];
        deviceid = []
        devicename = [];
        cardid = [];
        for pci_id in amd_pci_ids:
            did = pci_ide_to_drmcard_id(pci_id);
            deviceid.append(did);
            devicename.append(pci_ids_to_device_name(pci_id));
        #print(deviceid);
        for id in deviceid:
            i = check_device_id_dound(id);
            if(i != -1):
                cardid.append(i);
            else:
                print("ERROR deviceid not found!");
                exit(-1);
        print(cardid);
        return [amd_pci_ids, deviceid, devicename, cardid];

def remove_space(s1):
    out = "";
    for tmp in s1:
        if(tmp != " "):
            out = out + tmp;
    return out;


def kill_all_args_help():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('-killall', action='store_true', default=False, dest='boolean_killall', help='automatisch kill all coantiner lxc and docker run "./killall -killall"');
    results = parser.parse_args();
    if(results.boolean_killall == True):
        return 1;
    return 0;



def main():
    create_links();
    sargs = read_args();
    nosudo = 1;
    docker_user = "empty"
    docker_build = "archlinux_std_docker";
    gpu_render = "0";
    gpu_render_2 = "0";

    disk_device_name = "cd/dvd";
    zugriff_auf_media = 0; #1 = True
    sav_home_docker_folder = 0;
    share_folder_daten = 0;
    share_folder1_aktiv = 0;
    share_folder1 = "";
    network_disable = 1;
    steam_controller_bool = 0;
    usb_sharing = 0;
    usb_name = ""
    usb_hidraw_name = "";#cat < /sys/class/hidraw/hidraw5/device/uevent | grep "Valve Software Steam Controller"

    abspath = os.path.abspath(sys.argv[0])
    basename = os.path.basename(abspath)
    dirname = os.path.dirname(abspath)
    create_a_new_home_data_fodler(basename);
    config = loading_json_file(dirname + "/config_file_json");

    docker_input = "";
    maxmemory = -1;
    maxcpus = -1;
    network_host = "0";
    portforwding = "";
    dbus_rw = 0;
    pacman_cache = "";
    dns = "";
    ipv4 = "";
    wireguard_fix = 0;
    run_in_background = 0;
    ttyon = 0;
    pacman_pakgage_install = pacman_pkgage_install;
    bluethoot_passthrough = 0;
    hidraw_acs_overrides_patch = 0;
    ipv6_privacy = 0;
    faketime = "";
    wine_32bit_speed_hak = 0;
    read_only = "";
    read_only_password = "";
    json_config_Verison = "";
    amd_gpu_raytrasing_allgpus = 0;
    amd_gpu_raytrasing_rdan2_only = 0;
    string_bash_add = "";
    string_bash_add_root = "";
    wine_fsr = -1;
    manager_vm_fodler = "";
    debug = DEBUG_MODE;
    optional_array = "";
    smart_acces_meomory = 0;
    vulkan_index = "";
    vulkan_device_name = "";
    steam_proton_run_without_steam = 0;
    mango_hud = 0;
    vkbasalt = 0;
    freesync = 0;
    vsync = 1;

    #new
    docker_system = 1;#1 docker 0 lxc
    lxc_readonly = 1;#1 root readonly
    lxc_network_mac = "0";
    lxc_tmp_auto_create_id = -1;
    lxc_network_bridge_link = "";
    lxc_start_vm_lxc_device_coammds = "";
    lxc_string_add_config = "";
    lxc_mount_switch = 0;
    docker_system_bak = docker_system;
    lxc_readonly_bak = lxc_readonly;
    docker_disable_ipv6 = 0;
    #lxc staticip wird benotigt und cd dns server angaber

    nvidia_dlss = 0;
    nvidia_dlss_non_nvida_gpu = 0;
    wineesync_and_winefsync = 0;
    pulseaudio_stotterfix = 0;
    amdgpu_nohyperz = 0;
    string_radv_pertest = [];
    amdgpu_pswave32 = 0;
    amdgpu_nv_ms = 0;
    amdgpu_vrs = "";
    pluseaudio_sdl_fix = 0;

    i = 0;
    while True:
        if(i >= len(config)):
            break;
        tmp = config[i];
        if(tmp[0] == "docker_user"):
            docker_user = tmp[1];
        elif(tmp[0] == "gpu_render"):
            gpu_render = tmp[1];
        elif(tmp[0] == "disk_device_name"):
            disk_device_name = tmp[1];
        elif(tmp[0] == "zugriff_auf_media"):
            zugriff_auf_media = int(tmp[1]);
        elif(tmp[0] == "sav_home_docker_folder"):
            sav_home_docker_folder = int(tmp[1]);
        elif(tmp[0] == "share_folder_daten"):
            share_folder_daten = int(tmp[1]);
        elif(tmp[0] == "share_folder1_aktiv"):
            share_folder1_aktiv = int(tmp[1]);
        elif(tmp[0] == "share_folder1"):
            share_folder1 = tmp[1];
        elif(tmp[0] == "network_disable"):
            network_disable = int(tmp[1]);
        elif(tmp[0] == "steam_controller_bool"):
            steam_controller_bool = int(tmp[1]);
        elif(tmp[0] == "usb_sharing"):
            usb_sharing = int(tmp[1]);
        elif(tmp[0] == "usb_name"):
            usb_name = tmp[1];
        elif(tmp[0] == "usb_hidraw_name"):
            usb_hidraw_name = tmp[1];
        elif(tmp[0] == "docker_build"):
            docker_build = tmp[1];
        elif(tmp[0] == "docker_input"):
            docker_input = tmp[1];
        elif(tmp[0] == "maxmemory"):
            maxmemory = int(tmp[1]);
        elif(tmp[0] == "maxcpus"):
            maxcpus = int(tmp[1]);
        elif(tmp[0] == "network_host"):
            network_host = tmp[1];
        elif(tmp[0] == "portforwding"):
            portforwding = tmp[1];
        elif(tmp[0] == "dbus_rw"):
            dbus_rw = int(tmp[1]);
        elif(tmp[0] == "pacman_cache"):
            pacman_cache = tmp[1];
        elif(tmp[0] == "dns"):
            dns = tmp[1];
        elif(tmp[0] == "ipv4"):
            ipv4 = tmp[1];
        elif(tmp[0] == "wireguard_fix"):
            wireguard_fix = int(tmp[1]);
        elif(tmp[0] == "nosudo"):
            nosudo = int(tmp[1]);
        elif(tmp[0] == "run_in_background"):
            run_in_background = int(tmp[1]);
        elif(tmp[0] == "ttyon"):
            ttyon = int(tmp[1]);
        elif(tmp[0] == "pacman_pakgage_install"):
            pacman_pakgage_install = tmp[1];
        elif(tmp[0] == "bluethoot_passthrough"):
            bluethoot_passthrough = int(tmp[1]);
        elif(tmp[0] == "hidraw_acs_overrides_patch"):
            hidraw_acs_overrides_patch = int(tmp[1]);
        elif(tmp[0] == "ipv6_privacy"):
            ipv6_privacy = int(tmp[1]);
        elif(tmp[0] == "faketime"):
            faketime = tmp[1];
            if(faketime != "" and debug == 1):
                print("faketime aktiv!");
                print("faketime: " + faketime)
        elif(tmp[0] == "wine_32bit_speed_hak"):
            wine_32bit_speed_hak = int(tmp[1]);
            if(debug == 1):
                print("wine_32bit_speed_hak aktiv!");
        elif(tmp[0] == "read_only"):
            read_only = tmp[1];
            if(debug == 1):
                print("bearbeitung_Schutz aktiv!")
        elif(tmp[0] == "read_only_password"):
            read_only_password = tmp[1];
            if(debug == 1):
                print("bearbeitung_Schutz mit Pasword aktiv!")
        elif(tmp[0] == "amd_gpu_raytrasing_allgpus"):
            amd_gpu_raytrasing_allgpus = int(tmp[1]);
        elif(tmp[0] == "amd_gpu_raytrasing_rdan2_only"):
            amd_gpu_raytrasing_rdan2_only = int(tmp[1]);
        elif(tmp[0] == "wine_fsr"):
            wine_fsr = int(tmp[1]);
        elif(tmp[0] == "manager_vm_fodler"):
            manager_vm_fodler = tmp[1];
        elif(tmp[0] == "optional_array"):
            optional_array = tmp[1];
            if(debug == 1):
                print("optional_array: ", optional_array);
        elif(tmp[0] == "smart_acces_meomory"):
            smart_acces_meomory = int(tmp[1]);
        elif(tmp[0] == "vulkan_device_name"):
            vulkan_device_name = tmp[1];
        elif(tmp[0] == "steam_proton_run_without_steam"):
            steam_proton_run_without_steam = int(tmp[1]);
        elif(tmp[0] == "mango_hud"):
            mango_hud = int(tmp[1]);
        elif(tmp[0] == "vkbasalt"):
            vkbasalt = int(tmp[1]);
        elif(tmp[0] == "freesync"):
            freesync = int(tmp[1]);
        elif(tmp[0] == "vsync"):
            vsync = int(tmp[1]);
        elif(tmp[0] == "docker_system"):
            docker_system = int(tmp[1]);
        elif(tmp[0] == "lxc_readonly"):
            lxc_readonly = int(tmp[1]);
        elif(tmp[0] == "lxc_network_mac"):
            lxc_network_mac = tmp[1];
        elif(tmp[0] == "lxc_network_bridge_link"):
            lxc_network_bridge_link = tmp[1];
        elif(tmp[0] == "docker_disable_ipv6"):
            docker_disable_ipv6 = int(tmp[1]);
        elif(tmp[0] == "nvidia_dlss"):
            nvidia_dlss = int(tmp[1]);
        elif(tmp[0] == "wineesync_and_winefsync"):
            wineesync_and_winefsync = int(tmp[1]);
        elif(tmp[0] == "nvidia_dlss_non_nvida_gpu"):
            nvidia_dlss_non_nvida_gpu = int(tmp[1]);
        elif(tmp[0] == "pulseaudio_stotterfix"):
            pulseaudio_stotterfix = int(tmp[1]);
        elif(tmp[0] == "amdgpu_nohyperz"):
            amdgpu_nohyperz = int(tmp[1]);
        elif(tmp[0] == "amdgpu_pswave32"):
            amdgpu_pswave32 = int(tmp[1]);
        elif(tmp[0] == "amdgpu_nv_ms"):
            amdgpu_nv_ms = int(tmp[1]);
        elif(tmp[0] == "amdgpu_vrs"):
            amdgpu_vrs = tmp[1];
        elif(tmp[0] == "pluseaudio_sdl_fix"):
            pluseaudio_sdl_fix = int(tmp[1]);
        elif(tmp[0] == "sav_Version"):
            json_config_Verison = tmp[1];
        else:
            print("ERROR config file corrupt");
            print(tmp);
            exit(1);
        i = i +1;

    basename_bak = basename;
    if(basename == "killall"):
        tmp = kill_all_args_help();
        docker_killall(docker_build, tmp);
        exit(0)

    docker_system_bak = docker_system;
    lxc_readonly_bak = lxc_readonly;

    #import pdb
    #pdb.set_trace()
    b1 = 0;
    while True:
        if(docker_system == 0):
            #lxc
            if(network_disable == 0):
                if(network_host == "" or network_host == "0"):
                    network_host = lxc_find_eth0_network_bridge();
                    basename = "edit_config_sav";
                    b1 = 1;
        if(b1 == 1):
            if(lxc_network_bridge_link == ""):
                xc_network_bridge_link = lxc_find_eth0_network_Device();
                basename = "edit_config_sav";
                break;
            else:
                if(lxc_exist_newtworkdevice(lxc_network_bridge_link) == 0):
                    network_host = lxc_find_eth0_network_bridge();
                    lxc_network_bridge_link = lxc_find_eth0_network_Device();
                    basename = "edit_config_sav";
                break;
        else:
            break;

    if(docker_system == 0):
        #lxc
        pass;
    if(lxc_network_mac == ""):
        lxc_network_mac = lxc_create_a_new_random_mac_addr();

    if(docker_system == 0):
        #lxc
        if(lxc_network_mac == "0"):
            pass;
            #lxc_network_mac = lxc_create_a_new_random_mac_addr();


    if(json_config_Verison.find("crypt") == -1):
        file_write_json(dirname + "/config_file_json", docker_user, gpu_render, disk_device_name, zugriff_auf_media, sav_home_docker_folder, share_folder_daten, share_folder1_aktiv, share_folder1, network_disable, steam_controller_bool, usb_sharing, usb_name, usb_hidraw_name, docker_build, maxmemory, maxcpus, network_host, portforwding, dbus_rw, pacman_cache, dns, ipv4, wireguard_fix, nosudo, run_in_background, ttyon, pacman_pakgage_install, docker_input, bluethoot_passthrough,
            hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, read_only, read_only_password, amd_gpu_raytrasing_allgpus, amd_gpu_raytrasing_rdan2_only, wine_fsr, manager_vm_fodler, optional_array);


    if(basename == "system_only3"):
        basename = "command_root_lxc";
        lxc_readonly = 0;
        lxc_mount_switch = 1;
    user_id = -1;
    if(docker_system == 0):
        #lxc
        #user_id = alnalsye_user_id(sys.argv[1]);
        user_id = os.getuid();
    else:
        #docker
        user_id = os.getuid();

    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config"):
        docker_system = 1;

    custom_command = "";
    optical_disk = read_scsi(disk_device_name, docker_system);
    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
        pass;
    else:
        create_a_cdrom_mount_file_per_dev(optical_disk, docker_user, dirname);

    if(bluethoot_passthrough == 1):
        hidraw_acs_overrides_patch = 1;

    if(hidraw_acs_overrides_patch == 1):
        if(debug == 1):
            print("hidraw_acs_overrides_patch aktiv!");

    emptyfolder = dirname + "/xinput_tmp";

    if(basename == "command"):
        custom_command = sargs;
    if(basename == "command_root"):
        custom_command = sargs;
    if(basename == "command_root_lxc"):
        custom_command = sargs;
    if(basename == "system_only"):
        custom_command = sargs;
    if(basename == "system_only2"):
        custom_command = sargs;
    if(basename == "build"):
        if(debug == 1):
            print("disable nosudo!")
        nosudo = 0;

    if(os.path.isfile(dirname+"/hidraw_acs_overrides_patch.py") == False):
        print("hidraw_acs_overrides_patch.py file not found!");
        exit(-1);
    if(os.path.isfile(dirname+"/chmod_check.py") == False):
        print("chmod_check.py file not found!");
        exit(-1);



    base_args = [
        "docker", "--privileged",
        #"-e", "XDG_RUNTIME_DIR=" + os.environ["XDG_RUNTIME_DIR"],
        #"-e", "DBUS_SESSION_BUS_ADDRESS=" + os.environ["DBUS_SESSION_BUS_ADDRESS"],
        "-e", "XDG_RUNTIME_DIR=" + "/etc/user/" + str(user_id),
        "-e", "DBUS_SESSION_BUS_ADDRESS=" + "unix:path=/etc/user/" + str(user_id) + "/bus",
        "-e", "LANG=" + os.environ["LANG"],
        #"-e", "PWD=/home/" + docker_user,
        "-h", platform.node(),
        #"-v", "/dev/dri:/dev/dri",
        #"-v", "/dev/shm:/dev/shm",
        #"--device", "/dev/vga_arbiter:/dev/vga_arbiter",
        #"-v", "/etc/localtime:/etc/localtime:ro",
        #"-v", "/etc/machine-id:/etc/machine-id:ro",
        #"-v", "/run/user/" + ":/run/user/" + ":ro",
        #"-v", "/run/user/" + str(user_id) + ":/etc/user/" + str(user_id) + ":rw",
        #"-v", "/run/user/" + str(user_id) + "/pulse:/etc/user/" + str(user_id) + "/pulse:ro",
        #"-v", "/dev/snd:/dev/snd",
        #"-v", "/tmp/.X11-unix:/tmp/.X11-unix:rw",
        "-v", "/var/run/dbus/system_bus_socket:/var/run/dbus/system_bus_socket:ro",
        #"-v", "/var/lib/dbus:/var/lib/dbus",
        #"-v", dirname+"/pulse-client.conf:/etc/pulse/client.conf:ro",
        #"-v", "/dev/loop0:/dev/loop0:ro",
        #"-v", dirname+"/hostname:/etc/hostname:ro",
        #"-v", dirname+"/mirrorlist:/etc/pacman.d/mirrorlist:ro",

        #archlinux locale gen fix
        ##"-v", "/etc/locale.conf:/etc/locale.conf:ro",
        ##"-v", "/etc/locale.gen:/etc/locale.gen:ro",
        #"-v", "/tmp/.X11-unix:/tmp/.X11-unix:rw",
        "--device", "/dev/fb0",
        #"-v", "/dev/snd:/dev/snd",
        "--group-add", "video",
        "--security-opt=seccomp:unconfined",
        #"--group-add", "render",
        #"--group-add", "optical",
        #"--group-add", "input",
        #"--device", "/dev/snd",
        #"-v", "/etc/vconsole.conf:/etc/vconsole.conf:ro",
        #"-e", "KEYMAP=de-latin1-nodeadkeys",
        #"-v", "/dev/input/:/dev/input/:ro",
        "-v", dirname+"/chmod_check.py:/root/chmod_check.py:ro",
        "-v", dirname+"/hidraw_acs_overrides_patch.py:/root/hidraw_acs_overrides_patch.py:ro",
    ]

    if(docker_system == 1):
        #docker
        base_args.append("-v");
        base_args.append("/run/user/" + str(user_id) + ":/etc/user/" + str(user_id) + ":rw");
        base_args.append("-v");
        base_args.append("/run/user/" + str(user_id) + "/pulse:/etc/user/" + str(user_id) + "/pulse:ro");
    else:
        base_args.append("-v");
        base_args.append("/run/user:/etc/user:rw");
        base_args.append("-v");
        base_args.append("/run/user/" + str(user_id) + ":/etc/user/"  + str(user_id) + ":rw");

    if(docker_system == 0):
        #lxc
        if(lxc_readonly == 1):
            base_args.append("-v");
            base_args.append(dirname+"/pulse-client.conf:/etc/pulse/client.conf:ro");

    if(docker_system == 1):
        #docker
        base_args.append("-v");
        base_args.append("/dev/loop0:/dev/loop0:ro");

    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
        base_args.append("-v");
        base_args.append("/dev/dri")
        pass;
    else:
        #if(vulkan_index != ""):
        #    string_bash_add = string_bash_add + "export VKD3D_VULKAN_DEVICE=" + str(vulkan_index) + "\n"
        #base_args.append("-v");
        #base_args.append("/dev/dri");
        #import pdb; pdb.set_trace();
        if(gpu_render != ""):
            base_args = device_folder_passthrough("/dev/dri", base_args);
            if(gpu_Render_check_is_int(gpu_render) == 0):
                gpu_render_2 = gpu_render;
                atmp = read_all_dri_prime_device(basename);
                for i in range(len(atmp)):
                    tmp = atmp[i].split(" (")[0];
                    if(tmp == gpu_render):
                        gpu_render_2 = str(i);
                        if(i != 0):
                            vulkan_index = str(i);
                        break;
                if(gpu_Render_check_is_int(gpu_render_2) == 0):
                    if(debug == 1):
                        print("gpu not found! setze auf 0 gpu render!")
                    gpu_render_2 = "0";
                    #vulkan_index = "0";
            else:
                gpu_render_2 = gpu_render;
                if(gpu_render != "0"):
                    vulkan_index = gpu_render;
        elif(docker_system == 0):
            #lxc
            if(vulkan_device_name != ""):
                #lxc
                card = lxc_find_gpu_amd_Card_Nummber(vulkan_device_name);
                if(card == -1):
                    print("ERROR vkulan device not found! vulkan_device name wrong!")
                    exit(-1);
                else:
                    base_args.append("--device");
                    base_args.append("/dev/dri/card" + str(card) + ":/dev/dri/card0");
                    #base_args.append("/dev/dri/card" + str(card));
                    base_args.append("--device");
                    base_args.append("/dev/dri/renderD" + str(card + 128) + ":/dev/dri/renderD128");
                    #base_args.append("/dev/dri/renderD" + str(card + 128));
            else:
                #base_args.append("-v");
                #base_args.append("/dev/dri")
                base_args = device_folder_passthrough("/dev/dri", base_args);
        else:
            #docker
            if(vulkan_device_name != ""):
                if(gpu_render == ""):
                    if(basename == "system_only" or basename == "system_only2" or basename == "build"):
                        pass;
                    else:
                        id = suche_vulkandevice(vulkan_device_name);
                        if(id != 0):
                            string_bash_add = string_bash_add + "export MESA_VK_DEVICE_SELECT=" + id + "\n"
                        else:
                            print("ERROR vkulan device not found! vulkan_device name wrong!")

    #if( docker_system == 0 ):
    if(False):
        #lxc
        if(lxc_readonly == 0):
            base_args.append("-v");
            base_args.append("/dev/dri")
        else:
            exit(-1)

    if(os.path.isfile("/etc/localtime") == True):
        base_args.append("-v");
        base_args.append("/etc/localtime:/etc/localtime:ro");
    else:
        if(os.path.isdir("/etc/localtime") == True):
            print("/etc/localtime is a dir!")
        else:
            print("/etc/localtime not found!")
        exit(-1);

    if(docker_system == 0):
        #lxc
        base_args = device_folder_passthrough("/dev/snd", base_args);
        base_args = device_folder_passthrough("/dev/shm", base_args);
    else:
        #docker
        base_args.append("-v");
        base_args.append("/dev/snd");
        base_args.append("-v");
        base_args.append("/dev/snd");

    if(docker_system == 0):
        #lxc
        if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
            #base_args = device_folder_passthrough("/dev/dri", base_args)
            pass;
        else:
            if(vulkan_device_name != ""):
                vkdevice_card0 = lxc_find_gpu_amd_Card_Nummber(vulkan_device_name);
                base_args = lxc_dri_prime_to_dvice_paths(vkdevice_card0, base_args)
                pass;
            #else:
            #    base_args = device_folder_passthrough("/dev/dri", base_args)
    else:
        pass;
        #docker
        #base_args = lxc_dri_prime_to_dvice_paths(gpu_render_2, base_args)
        #base_args = device_folder_passthrough("/dev/dri", base_args);


    if(docker_system == 0):
        #lxc
        #base_args.append("-v2");
        #base_args.append(dirname + "/tmp:/dev/bsg:rw");
        pass;
    base_args.append("-e")
    base_args.append("DRI_PRIME=" + gpu_render_2);
    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
        pass;
    else:
        if(basename != "build"):
            base_args.append("--ipc=\"host\"");
            base_args.append("--shm-size=\"8G\"");
            pass

        if(ttyon == 1):
            if(debug == 1):
                print("ttyon aktive");
                print("Terminal on Gui off");
            #base_args.append("-t");
        if(os.path.isfile(dirname+"/machine-id") == True):
            if(debug == 1):
                print("found machine-id from fodler");
            base_args.append("-v");
            base_args.append(dirname+"/machine-id:/etc/machine-id:ro");
        else:
            if(debug == 1):
                print("found machine-id from /etc/ fodler");
            base_args.append("-v");
            base_args.append("/etc/machine-id:/etc/machine-id:ro");

    if(dbus_rw == 1):
        if(debug == 1):
            print("dbus_rw on");
        base_args.append("-v");
        base_args.append("/var/lib/dbus:/var/lib/dbus");
        if(docker_system == 1):
            base_args.append("-v");
            base_args.append("/tmp/.X11-unix:/tmp/.X11-unix:rw");
        else:
            base_args.append("-v");
            base_args.append("/tmp/.X11-unix:/etc/tmp/.X11-unix:rw");
        #base_args.append("-v");
        #base_args.append("/dev/snd:/dev/snd");
        base_args = device_folder_passthrough("/dev/snd", base_args);
    else:
        if(docker_system == 1):
            base_args.append("-v");
            base_args.append("/tmp/.X11-unix:/tmp/.X11-unix:ro");
        else:
            base_args.append("-v");
            base_args.append("/tmp/.X11-unix:/etc/tmp/.X11-unix:ro");

    if(os.path.isfile(dirname+"/mirrorlist") == True):
        base_args.append("-v");
        base_args.append(dirname+"/mirrorlist:/etc/pacman.d/mirrorlist:ro");
        if(debug == 1):
            print("add pacman mirrolist");

    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
        pass;
    else:
        if(docker_input != ""):
            if(docker_input == "*"):
                base_args.append("-v");
                base_args.append("/dev/input/:/dev/input/:rw");
                if(debug == 1):
                    print("xinput device all add");
            elif(docker_input == "block"):
                if(debug == 1):
                    print("add block empty folder for xinput");
                os.system("mkdir -p " + emptyfolder + "/by-id")
                os.system("mkdir -p " + emptyfolder + "/by-path")
                #os.system("sudo chmod 000 -R " + emptyfolder)
                base_args.append("-v");
                base_args.append(emptyfolder + ":"+ "/dev/input" + ":rw");




                #base_args.append("-v");
                #base_args.append(emptyfolder + ":"+ "/dev/input/event3" + ":rw");
                #out = add_input_device(docker_input);
            else:
                #print("add empty folder for xinput");
                base_args.append("-v");
                base_args.append(emptyfolder + ":"+ "/dev/input" + ":rw");
                out = add_input_device(docker_input);
                if(debug == 1):
                    print("xinput device add");
                for tmp in out:
                    tmp2 = os.path.realpath(tmp);
                    base_args.append("-v");
                    base_args.append(tmp2 + ":"+ tmp2 + ":ro");
                    print(tmp);
                    print(tmp2 + ":"+ tmp2 + ":ro");

        i = 0;
        for tmp in optical_disk[0]:
            base_args.append("--device");
            base_args.append(tmp);
        for tmp in optical_disk[1]:
            base_args.append("--device");
            base_args.append(tmp);
        for tmp in optical_disk[2]:
            base_args.append("--device");
            base_args.append(tmp);
        for tmp in optical_disk[3]:
            base_args.append("--device");
            base_args.append(tmp);

        if(zugriff_auf_media == 1):
            if(os.path.isdir("/run/media") == False):
                if(debug == 1):
                    print("ERROR /run/media folder not found");
            else:
                base_args.append("-v");
                base_args.append("/run/media:/run/media:rw");
                if(debug == 1):
                    print("acces allow from /run/media on");

    if(sav_home_docker_folder == 1):
            if(basename != "command_root_lxc"):
                if(os.path.isdir(os.path.join(dirname, "home")) == False):
                    print(read_users_name())
                    os.system("mkdir \"" + os.path.join(dirname, "home") + "\"");
                    time.sleep(1)
                    os.system("sudo chmod -R  777 \"" + os.path.join(dirname, "home") + "\"");
                    os.system("sudo chown -R " + read_users_name() + ":users  \"" + os.path.join(dirname, "home") + "\"");
                base_args.append("-v");
                base_args.append(dirname+"/home:/home/" + docker_user + ":rw");
                if(debug == 1):
                    print("sav home folder");

    if(share_folder_daten == 1):
            if(basename != "command_root_lxc"):
                if(os.path.isdir(os.path.join(dirname, "daten")) == False):
                    os.system("mkdir \"" + os.path.join(dirname, "daten") + "\"");
                    os.system("sudo chmod -R  777 \"" + os.path.join(dirname, "daten") + "\"");
                    os.system("sudo chown -R " + read_users_name() + ":users  \"" + os.path.join(dirname, "daten") + "\"");
                base_args.append("-v");
                base_args.append(dirname+"/daten:/home/" + docker_user + "/daten:rw");
                base_args.append("-v");
                base_args.append(dirname+"/daten:/root" + "/daten:rw");
                if(debug == 1):
                    print("share daten fodler");
    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
        pass;
    else:
        if(basename != "command_root_lxc"):
            if(share_folder1_aktiv == 1):
                sharingfolders = share_folder1.split("^");
                if(True):
                    for tmp in sharingfolders:
                        if(len(tmp) >= 1 and tmp[0] != "/" and tmp.find(":") == -1):
                            if(os.path.isdir(dirname+"/"+tmp) == True):
                                base_args.append("-v");
                                base_args.append(dirname+"/"+tmp + ":" + "/home/" + docker_user  + "/" + tmp + ":rw");
                                base_args.append("-v");
                                base_args.append(dirname+"/"+tmp + ":" + "/root/" + tmp + ":rw");
                                if(debug == 1):
                                    print("share fodler " +dirname+"/"+tmp + ":" + "/home/" + docker_user + "/" + tmp + ":rw" + " aktive");
                                    print("share fodler " +dirname+"/"+tmp + ":" + "/root/" + tmp + ":rw" + " aktive");
                            else:
                                if(debug == 1):
                                    print("ERROR share_folder1 folder not found : " + dirname+"/"+tmp);
                        elif(tmp.find(":") == -1):
                            if(os.path.isdir(tmp) == False):
                                if(os.path.isdir(dirname+"/"+tmp) == True):
                                    base_args.append("-v");
                                    base_args.append(dirname+"/"+tmp + ":" + tmp + ":rw");
                                    if(debug == 1):
                                        print("share fodler " + tmp + " aktive");
                                else:
                                    base_args.append("-v");
                                    base_args.append(tmp + ":" + tmp + ":rw");
                                    if(debug == 1):
                                        print("share fodler " + tmp + " aktive");
                            else:
                                base_args.append("-v");
                                base_args.append(tmp + ":" + tmp + ":rw");
                                if(debug == 1):
                                    print("share fodler " + tmp + " aktive");
                        else:
                            s1 = tmp.split(":")[0];
                            if(os.path.isdir(dirname+"/"+s1) == True):
                                base_args.append("-v");
                                base_args.append(dirname+"/"+tmp);
                                if(debug == 1):
                                    print("share fodler " + dirname+s1 + " aktive");
                            elif(os.path.isdir(s1) == True ):
                                base_args.append("-v");
                                base_args.append(tmp);
                                if(debug == 1):
                                    print("share fodler " + tmp + " aktive");
                            elif(os.path.isdir(dirname+"/"+s1) == False ):
                                if(os.path.isfile(dirname+"/"+s1) == False):
                                    if(debug == 1):
                                        print("ERROR share_folder1 folder not found : " + dirname+"/"+s1);
                                else:
                                    base_args.append("-v");
                                    base_args.append(dirname+"/"+tmp);
                                    if(debug == 1):
                                        print("share fodler " + tmp + " aktive");
                            else:
                                base_args.append("-v");
                                base_args.append(dirname+"/"+tmp);
                                if(debug == 1):
                                    print("share fodler " + tmp + " aktive");


        if(network_disable == 1):
            base_args.append("--network");
            base_args.append("none");
            if(debug == 1):
                print("Network disable");


    if(os.path.isfile(dirname+"/hostname") == True):
        base_args.append("-v");
        base_args.append(dirname+"/hostname:/etc/hostname:ro");

    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
        pass;
    else:
        if(usb_sharing == 1):
            base_args.append("-v");
            base_args.append("/dev/bus/:/dev/bus/:rw");
            base_args.append("-v");
            base_args.append("/dev/usb:/dev/usb:rw");
            pass;

        if(os.path.isdir(dirname+"/share") == True or os.path.islink(dirname+"/share") == True):
            if(basename != "command_root_lxc"):
                if(debug == 1):
                    print("sharing the share fodler on");
                base_args.append("-v");
                base_args.append(dirname+"/share:/home/" + docker_user + "/share:rw");
                base_args.append("-v");
                base_args.append(dirname+"/share:/root/share:rw");
        if(usb_sharing == 1):
            if(usb_name.find("^") == -1):
                if(debug == 1):
                    print("usb_sharing enabled");
                    print(usb_name);
                    print(usb_hidraw_name);
                usb = usb_pasthrough(usb_name);
                usbdir = usb[0];
                usbdev = usb[1];
            else:
                usbdir = [];
                usbdev = [];
                s1 = usb_name.split("^");
                for tmp in s1:
                    if(debug == 1):
                        print("usb_sharing enabled");
                        print(tmp);
                    #print(usb_hidraw_name);
                    usb = usb_pasthrough(tmp);
                    usbdir = array_add_aarray(usbdir, usb[0]);
                    usbdev = array_add_aarray(usbdev, usb[1]);
            if(debug == 1):
                print(usb);
            if(len(usbdir) != 0):
                i = 0;
                while True:
                    if(i >= len(usbdir)):
                        break;
                    if(os.path.isdir("/dev/bus/usb/" +usbdir[i]) == True):
                        if(check_device_isopen("/dev/bus/usb/" +usbdir[i] + "/" + usbdev[i]) == 1):
                            base_args.append("-v");
                            base_args.append("/dev/bus/usb/" +usbdir[i] + "/" + usbdev[i]+ ":" + "/dev/bus/usb/" +usbdir[i] + "/" + usbdev[i]);
                        else:
                            if(debug == 1):
                                print("ERROR usb dev file not found!");
                                print("/dev/bus/usb/" +usbdir[i] + "/" + usbdev[i]);
                            break;
                    else:
                        if(debug == 1):
                            print("ERROR usb dev dir not found!");
                            print("/dev/bus/usb/" +usbdir[i]);
                        break;
                    i = i +1;
            else:
                if(debug == 1):
                    print("usb_name: \"" + usb_name + "\" not found");

            if(usb_hidraw_name.find("^") == -1):
                dev = read_hidraw_device(usb_hidraw_name);
                if(len(dev) != 0):
                    for tmp2 in dev:
                        base_args.append("--device");
                        base_args.append(tmp2);
                else:
                    if(debug == 1):
                        print("usb_hidraw_name: \"" + usb_hidraw_name + "\" not found");
            else:
                s1 = usb_hidraw_name.split("^");
                for tmp in s1:
                    dev = read_hidraw_device(tmp);
                    if(len(dev) != 0):
                        for tmp2 in dev:
                            base_args.append("--device");
                            base_args.append(tmp2);
                    else:
                        if(debug == 1):
                            print("usb_hidraw_name: \"" + tmp + "\" not found");


        if(steam_controller_bool == 1):
            if(usb_sharing != 1 and usb_name != "" and usb_hidraw_name != ""):
                if(debug == 1):
                    print("ERRROR enable usb_sharing and usb_name and usb_hidraw_name setzen");
            inputs = read_steam_Controller();
            i = 0;
            while True:
                if(i >= len(inputs)):
                    break;
                base_args.append("--device");
                #base_args.append(inputs[i] + ":" + inputs[i]);
                base_args.append(inputs[i]);
                i = i +1;
            base_args.append("-v");
            base_args.append("/run/dbus:/run/dbus");

        if(maxmemory != -1):
            if(debug == 1):
                print("set maxmemory to", maxmemory);
            base_args.append("--memory="+str(maxmemory) + "MB");
        if(maxcpus != -1):
            if(debug == 1):
                print("set cpus to", maxcpus);
            base_args.append("--cpus="+str(maxcpus));
        if(network_host != "" and network_host != "0" and network_disable == 0):
            if(debug == 1):
                print("network_host aktive");
            if(network_host.find("^") == -1):
                base_args.append("--net="+network_host);
            else:
                for tmp in network_host.split("^"):
                    base_args.append("--net="+tmp);
                    print("connect docker to network " + tmp + "!");
        if(portforwding != ""):
            if(debug == 1):
                print("portforwding aktive");
            base_args.append("-p")
            base_args.append(portforwding);
            #-p 8080:80
    if(pacman_cache != ""):
        if(debug == 1):
            print("pacman_cache aktive");
        base_args.append("-v");
        base_args.append(pacman_cache+":"+"/var/cache/pacman/pkg:ro");
        base_args.append("-v");
        base_args.append(pacman_cache+":"+"/mnt/pacman_cache_rw:rw");
        system("sudo chmod -R 777 " + pacman_cache);
        user = home = os.environ['USER'];
        system("sudo chown -R "+ user + ":users " + pacman_cache);

    dirname_tmp = "";
    if(docker_build != "folder_name"):
        dirname_tmp = docker_build;
    else:
        dirname_tmp = os.path.split(dirname)[-1];
    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
        pass;
    else:

        if(dns != ""):
            dns_ = dns.split("^");
            if(len(dns_) >= 1):
                for tmp in dns_:
                    base_args.append("--dns");
                    base_args.append(tmp);
                    if(debug == 1):
                        print("DNS Server wird auf", dns, "gesezt!");
            else:
                base_args.append("--dns");
                base_args.append(dns);
                if(debug == 1):
                    print("DNS Server wird auf", dns, "gesezt!");
        if(debug == 1):
            print(ipv4)
        if(ipv4 != ""):
            if(debug == 1):
                print("static ip gestzt auf " + ipv4);
            base_args.append("--ip");
            base_args.append(ipv4);
        #if(os.path.isfile("/etc/resolv.conf") == True):
        #    base_args.append("-v");
        #    base_args.append("/etc/resolv.conf:/etc/resolv.conf:ro");
        #    print("add /etc/resolv.conf to docker container!");
        if(ipv6_privacy == 1):
            if(debug == 1):
                print("Ipv6 privacy on!")

        if(wireguard_fix == 1):
            #wire guard patch
            base_args.append("--cap-add");
            base_args.append("net_admin");
            base_args.append("--cap-add");
            base_args.append("sys_module");
            base_args.append("-v");
            base_args.append("/usr/lib/modules:/usr/lib/modules:ro");
            base_args.append("--sysctl");
            base_args.append("net.ipv6.conf.all.disable_ipv6=0");
            base_args.append("--sysctl");
            base_args.append("net.ipv4.conf.all.src_valid_mark=1");
            base_args.append("-v");
            base_args.append("/sys/fs/cgroup:/sys/fs/cgroup:ro");
            #unboud fix 0.1a
            base_args.append("--ulimit nofile=5000:5000");
            if(debug == 1):
                print("wireguard_fix aktive!");

        if(run_in_background == 1):
            if(debug == 1):
                print("run_in_background aktiv!");
            base_args.append("-d");

        if(os.path.isfile("/etc/vconsole.conf") == True):
            base_args.append("-v");
            base_args.append("/etc/vconsole.conf:/etc/vconsole.conf:ro");
            base_args.append("-v");
            base_args.append("/etc/locale.conf:/etc/locale.conf:ro");
            base_args.append("-v");
            if(os.path.isfile("locale.gen") == True):
                base_args.append(dirname + "/locale.gen:/etc/locale.gen:ro");
            else:
                base_args.append("/etc/locale.gen:/etc/locale.gen:ro");
        else:
            if(debug == 1):
                print("ERRRO not found /etc/vconsole.conf!");

    if(os.path.isfile(dirname + "/" + "pipe.tmp") == False):
        f1 = open(dirname + "/" + "pipe.tmp", "w");
        f1.close();

    base_args.append("-v");
    base_args.append(dirname + "/" + "pipe.tmp:/etc/tmp/pipe.tmp:rw");

    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
        pass;
    else:
        if(amd_gpu_raytrasing_rdan2_only == 1):
            if(debug == 1):
                print("raytring for rdna 2 aktiv!")
            if(smart_acces_meomory == 0):
                string_radv_pertest.append("nosam");
                string_radv_pertest.append("rtwave64");
                #string_bash_add = string_bash_add + "export RADV_PERFTEST=nosam,rtwave64\n"
            else:
                string_radv_pertest.append("sam");
                string_radv_pertest.append("rtwave64");
                #string_bash_add = string_bash_add + "export RADV_PERFTEST=sam,rtwave64\n";
        elif(amd_gpu_raytrasing_allgpus == 1):
            if(debug == 1):
                print("raytrsing for all amdgpus aktiv!")
            if(smart_acces_meomory == 0):
                string_radv_pertest.append("nosam");
                string_radv_pertest.append("rt");
                #string_bash_add = string_bash_add + "export RADV_PERFTEST=nosam,rt\n"
            else:
                string_radv_pertest.append("sam");
                string_radv_pertest.append("rt");
                #tring_bash_add = string_bash_add + "export RADV_PERFTEST=sam,rt\n";
            #string_bash_add = string_bash_add + "export RADV_PERFTEST=rt\n";
        else:
            if(smart_acces_meomory == 0):
                string_radv_pertest.append("nosam");
                #string_bash_add = string_bash_add + "export RADV_PERFTEST=nosam\n"
            else:
                string_radv_pertest.append("sam");
                #string_bash_add = string_bash_add + "export RADV_PERFTEST=sam\n";


        if(wine_fsr != -1):
            if(wine_fsr <= 5 and wine_fsr >= 0):
                if(debug == 1):
                    print("wine fsr aktive stärke " + str(wine_fsr) + "!")
                string_bash_add = string_bash_add + "export  WINE_FULLSCREEN_FSR=1\nexport WINE_FULLSCREEN_FSR_STRENGTH="+ str(wine_fsr) + "\n";
            else:
                if(debug == 1):
                    print("wine fsr value nicht richtig!")
        if(smart_acces_meomory == 0):
            #string_bash_add = string_bash_add + "export RADV_PERFTEST=nosam\n"
            if(amd_gpu_raytrasing_rdan2_only == 1 or amd_gpu_raytrasing_allgpus == 1):
                string_bash_add = string_bash_add + "export VKD3D_CONFIG=no_upload_hvv,dxr\n"
                if(debug == 1):
                    print("smart_acces_meomory off mit raytrasing!");
            else:
                string_bash_add = string_bash_add + "export VKD3D_CONFIG=no_upload_hvv\n"
                if(debug == 1):
                    print("smart_acces_meomory off!");
        else:
            #string_bash_add = string_bash_add + "export RADV_PERFTEST=sam\n"
            if(basename != "command_root_lxc"):
                base_args.append("-v");
                base_args.append(dxvk_config_sam_on + ":/home/" + docker_user + "/daten/" + "dxvk_sam_on.conf:ro");
                string_bash_add = string_bash_add + "export DXVK_CONFIG_FILE=~/daten/dxvk_sam_on.conf\n"
                string_bash_add = string_bash_add + "export VKD3D_CONFIG=dxr\n"
                if(debug == 1):
                    print("smart_acces_meomory on with raytrasing!");

        if(gpu_render == ""):
            string_bash_add = string_bash_add + "unset DRI_PRIME\n"
            if(debug == 1):
                print("unset DRI_PRIME!");

        if(steam_proton_run_without_steam == 1):
            string_bash_add = string_bash_add + "export STEAM_COMPAT_CLIENT_INSTALL_PATH=~/.local/share/Steam\n"
            if(debug == 1):
                print("steam_proton_run_without_steam aktiv!");
        if(mango_hud == 1):
            string_bash_add = string_bash_add + "export MANGOHUD=1\n"
            if(debug == 1):
                print("mango_hud aktiv!");

        if(vkbasalt == 1):
            string_bash_add = string_bash_add + "export ENABLE_VKBASALT=1\n"
            if(debug == 1):
                print("vkbasalt aktiv!");

        if(vsync == 0):
            string_bash_add = string_bash_add + "export vblank_mode=0\n"
            if(debug == 1):
                print("freesync off vsync off aktiv!");
        elif(freesync == 1):
            string_bash_add = string_bash_add + "export vblank_mode=3\n"
            if(debug == 1):
                print("freesync aktiv!");
        else:
            string_bash_add = string_bash_add + "unset vblank_mode\n"
            if(debug == 1):
                print("freesync disable!");

    if(docker_system == 1):
        #docker
        if(lxc_network_mac != ""):
            if(lxc_network_mac != "0"):
                base_args.append("--mac-address");
                base_args.append(lxc_network_mac);

    #steam audio fix
    #string_bash_add_root = string_bash_add_root + "export SDL_AUDIODRIVER=pluse\n"
    #string_bash_add = string_bash_add + "export SDL_AUDIODRIVER=pluse\n"
    if(pluseaudio_sdl_fix == 1):
        string_bash_add_root = string_bash_add_root + "export SDL_AUDIODRIVER=pulseaudio\n";
        string_bash_add = string_bash_add + "export SDL_AUDIODRIVER=pulseaudio\n";

    if(pluseaudio_sdl_fix == 2):
        string_bash_add_root = string_bash_add_root + "export SDL_AUDIODRIVER=alsa\n";
        string_bash_add = string_bash_add + "export SDL_AUDIODRIVER=alsa\n";

    #Xorg DISAPLAY crash fix 0.2a
    string_bash_add_root = string_bash_add_root + "chmod -R 777 /tmp/.X11-unix\n";
    string_bash_add_root = string_bash_add_root + "chmod 755 /tmp/.X11-unix\n";
    string_bash_add_root = string_bash_add_root + "chown -R  " + docker_user + ":users /tmp/.X11-unix\n";
    string_bash_add_root = string_bash_add_root + "chmod +x /tmp/.X11-unix\n";

    if(True):
        tmp1 = check_env("WAYLAND_DISPLAY");
        if(tmp1 != -1):
            base_args.append("-e");
            base_args.append("WAYLAND_DISPLAY:" + tmp1);
            base_args.append("-e");
            base_args.append("DISPLAY=" + os.environ["DISPLAY"]);
            if(debug == 1):
                print("WAYLAND aktiv!")
        else:
            if(basename != "command_root_lxc"):
                if(debug == 1):
                    print("XORG aktiv!")
                base_args.append("-e");
                base_args.append("DISPLAY=" + os.environ["DISPLAY"]);
                base_args.append("-v");
                base_args.append( os.environ["XAUTHORITY"] + ":/home/" + docker_user + "/.Xauthority:rw");
                base_args.append("-v");
                base_args.append(os.environ["XAUTHORITY"] + ":/root" + "/.Xauthority:rw");
                os.system("chmod 777 " + os.environ["XAUTHORITY"] );
                #https://unix.stackexchange.com/questions/330366/how-can-i-run-a-graphical-application-in-a-container-under-wayland

        #if(basename != "build" and os.path.isdir("/usr/share/locale") == True):
        #    base_args.append("-v");
        #    base_args.append("/usr/share/locale:/usr/share/locale:ro");
        #    base_args.append("-v");
        #    base_args.append("/usr/lib/locale:/usr/lib/locale:ro");
        #else:
        #    print("ERROR not found /usr/share/locale on host system!");

    if(docker_system == 0):
        #lxc openvpn fix 0.1a
        base_args.append("--device");
        base_args.append("/dev/net/tun");
        #string_bash_add_root = string_bash_add_root + "chmod 777 /dev/net/tun\n"

    if(docker_system == 0):
        #lxc
        #string_bash_add_root = string_bash_add_root + "chmod -R 777  /etc\ndhcpcd eth0\nsleep 1\n"

        i = 1;
        for tmp in optical_disk[0]:
            string_bash_add_root = string_bash_add_root +  "mknod -m 777 " + tmp + " c 11 " + str(i) +"\n"

        if(lxc_readonly == 0):
            string_bash_add_root = string_bash_add_root + "chmod 755 /etc/sudo.conf\n"
            string_bash_add_root = string_bash_add_root + "chmod 755 -R /usr/lib/sudo/\n"
            string_bash_add_root = string_bash_add_root + "chmod -x  /etc/systemd/user.conf\n"
        if(lxc_readonly == 1):
            string_bash_add_root = string_bash_add_root + "chown -R root:video /dev/dri\n";
            base_args.append("--device");
            base_args.append("/dev/fuse");
            string_bash_add_root = string_bash_add_root + "chmod -R 777 /dev/fuse\n";
            string_bash_add_root = string_bash_add_root + "chown " + docker_user + ":users /dev/fuse\n";

        string_bash_add_root = string_bash_add_root + "/sbin/init systemd.legacy_systemd_cgroup_controller=yes\n"
        #string_bash_add_root = string_bash_add_root + "chmod u+s /usr/bin/fusermount\n";
        if(basename != "build"):
            string_bash_add_root = string_bash_add_root + lxc_add_groups_docker_user(basename, docker_build, docker_user);
        if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
            base_args.append("-v2");
            base_args.append(dirname + "/tmp:/tmp:rw");
            #base_args.append("-v");
            #base_args.append("/tmp/.X11-unix:/tmp/.X11-unix:ro");
        else:
            string_bash_add_root = string_bash_add_root + "rm -f /etc/resolv.conf\n"
            #string_bash_add_root = string_bash_add_root + "cp /etc/resolvconf.conf /etc/resolv.conf\ndhcpcd eth0\n"
            string_bash_add_root = string_bash_add_root + "dhcpcd eth0\n"
        if(lxc_readonly == 0):
            string_bash_add_root = string_bash_add_root + "chmod -R 777 /usr/bin/\n"
        else:
            os.system("sudo rm -r /tmp/lxc_empty")
            #os.system("mkdir /tmp/lxc_empty")
            base_args.append("-v2");
            base_args.append("/tmp/lxc_empty:/mnt:rw");
            #base_args.append("-v2");
            #base_args.append("/tmp/lxc_empty:/run:rw");
            #base_args.append("-v2");
            #base_args.append("/tmp/lxc_empty:/tmp:rw");
            #base_args.append("-v2");
            #base_args.append("/tmp/lxc_empty:/home:rw");
            #base_args.append("-v2");
            #base_args.append("/tmp/lxc_empty:/run/user:rw");
            pass;

        if(lxc_readonly == 1):
            os.system("mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/etc/run" )
            string_bash_add_root = string_bash_add_root + "/sbin/init systemd.legacy_systemd_cgroup_controller=yes\n"
            #string_bash_add_root = string_bash_add_root + "/root/chmod_check.py '" + docker_user + "' '" + str(user_id) + "' \n";

        string_bash_add_root = string_bash_add_root + "useradd -m -g users -G video,audio " + docker_user + "\n"
        if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build" or basename == "command_root_lxc"):
            pass;
            #lxc_readonly = 1;
        else:
            if(lxc_readonly == 1):
                base_args.append("-v");
                base_args.append(dirname + "/etc/passwd:/etc/passwd:ro");
                base_args.append("-v");
                base_args.append(dirname + "/etc/passwd:/etc/passwd+:ro");
                base_args.append("-v");
                base_args.append(dirname + "/etc/group:/etc/group:ro");
                base_args.append("-v");
                base_args.append(dirname + "/etc/shadow:/etc/shadow+:ro");
                os.system("mkdir " + dirname + "/etc")
                os.system("sudo cp /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/etc/passwd " + dirname + "/etc/passwd")
                os.system("sudo cp /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/etc/passwd+ " + dirname + "/etc/passwd")
                os.system("sudo cp /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/etc/group " + dirname + "/etc/group")
                os.system("sudo cp /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/etc/shadow " + dirname + "/etc/shadow")
                os.system("sudo chmod -R 777 " + dirname + "/etc");
                print(basename)
                if(lxc_edit_passwd_empty_user_id(dirname, docker_user, user_id) == -1):
                    print(basename)
                    exit(-1);
                lxc_edit_shadow_empty_user_id(dirname, docker_user, user_id)

        os.system("sudo mkdir -p  /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/etc/tmp ")
        string_bash_add_root = string_bash_add_root + "unset container\n"
        string_bash_add_root = string_bash_add_root + "mkdir /media/\n"
        string_bash_add_root = string_bash_add_root + "rm -r  /run/media\n"
        string_bash_add_root = string_bash_add_root + "rm  /run/media\n"
        string_bash_add_root = string_bash_add_root + "ln -sf /media /run/\n"

        string_bash_add_root = string_bash_add_root + "mkdir /dev/bsg\n"
        string_bash_add_root = string_bash_add_root + "chown root:optical /dev/sr0\n"
        string_bash_add_root = string_bash_add_root + "chown root:optical /dev/sg0\n"
        string_bash_add_root = string_bash_add_root + "ln -sf  /etc/tmp/pipe.tmp /tmp/pipe.tmp\n"
        string_bash_add_root = string_bash_add_root + "useradd -m -g users -G video,audio,wheel empty\n"
        #string_bash_add_root = string_bash_add_root + "mount -B /etc/user /run/user/\n"
        string_bash_add_root = string_bash_add_root + "chmod -R 777 /tmp/.X11-unix\n"
        string_bash_add_root = string_bash_add_root + "chmod -R 777 /etc/user\n"
        string_bash_add_root = string_bash_add_root + "chmod -R 777 /dev/dri\n"
        #base_args = device_folder_passthrough("/tmp/.X11-unix", base_args);
        string_bash_add_root = string_bash_add_root + "mkdir /tmp/.X11-unix\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X0 /tmp/.X11-unix/X0\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X1 /tmp/.X11-unix/X1\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X2 /tmp/.X11-unix/X2\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X3 /tmp/.X11-unix/X3\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X4 /tmp/.X11-unix/X4\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X5 /tmp/.X11-unix/X5\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X6 /tmp/.X11-unix/X6\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X7 /tmp/.X11-unix/X7\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X8 /tmp/.X11-unix/X8\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X9 /tmp/.X11-unix/X9\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X10 /tmp/.X11-unix/X10\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X11 /tmp/.X11-unix/X11\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X12 /tmp/.X11-unix/X12\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X13 /tmp/.X11-unix/X13\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X14 /tmp/.X11-unix/X14\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X15 /tmp/.X11-unix/X15\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/tmp/.X11-unix/X16 /tmp/.X11-unix/X16\n";

        #string_bash_add_root = string_bash_add_root + "ln -sf /mnt/run/media /run/media\n";
        #string_bash_add_root = string_bash_add_root + "rm  -r /run/user\n";
        string_bash_add_root = string_bash_add_root + "ln -sf /etc/user/ /run/user\n";
        #string_bash_add_root = string_bash_add_root + "ln -sf /etc/user/1 /run/user/" + str(user_id) + " \n";

        #string_bash_add_root = string_bash_add_root + "mkdir /run/user/\n"
        string_bash_add_root = string_bash_add_root + "chown " + docker_user + ":users /run/user/\n"

        if(dns != ""):
            #string_bash_add_root = string_bash_add_root + "rm /etc/resolv.conf\n"
            string_bash_add_root = string_bash_add_root + "echo 'nameserver " + dns + "' >/etc/resolv.conf\n"
            string_bash_add_root = string_bash_add_root + "chmod 777 /etc/resolv.conf\n";
        else:
            #string_bash_add_root = string_bash_add_root + "rm /etc/resolv.conf\n"
            string_bash_add_root = string_bash_add_root + "echo 'nameserver 8.8.8.8' >/etc/resolv.conf\n"
            string_bash_add_root = string_bash_add_root + "chmod 777 /etc/resolv.conf\n";
            print("Google dns server use!");

        if(dbus_rw == 1):
            string_bash_add_root = string_bash_add_root + "chown " + docker_user + ":users -R /tmp/.X11-unix/\n"
            string_bash_add_root = string_bash_add_root + "chown " + docker_user + ":users -R /etc/tmp/.X11-unix/\n"


        #string_bash_add_root = string_bash_add_root + "ln -sf /etc/run/media /run/media\n";


        #string_bash_add_root = string_bash_add_root + "chmod -R 777 /run/media\n"




        #base_args.append("-v");
        #base_args.append("/dev/null");
        #/dev/null
        #base_args.append("-v");
        #base_args.append("/etc/resolv.conf:/etc/resolvconf.conf:ro");
        #base_args.append("-v");
        #base_args.append("/etc/resolv.conf:/etc/resolv.conf:ro");


        base_args.append("-v");
        base_args.append(dirname + "/pacman.conf:/etc/pacman.conf:ro");
        #base_args.append("-v");
        #base_args.append("/tmp:/tmp:ro")
        base_args.append("-e");
        base_args.append("XAUTHORITY=/home/" + docker_user + "/.Xauthority");
        base_args.append("-e");
        base_args.append("HOSTNAME=" + platform.node());
        string_bash_add_root = string_bash_add_root + "hostname $HOSTNAME\n"


        out = lxc_converter_docker_array_reading(base_args);
        paths = out[0];
        variable = out[1];
        paths2 = out[2];
        devices = out[3];
        tmp = lxc_covert_device_array_to_string(devices, "");
        string_bash_add_root  = string_bash_add_root + tmp[1]
        string_bash_add_root = string_bash_add_root + "chmod -R 777 /dev/bsg\n";

        string_bash_add_root = string_bash_add_root + "ln -sf /dev/sr0 /dev/cdrom\n"
            #string_bash_add_root = string_bash_add_root + "ln -sf \"" + tmp1 + "\" \"" + tmp2 + "\"\n"
        #lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + tmp[0]


        #hostname $HOSTNAME
        #f1 = open(dirname + "/passwd", "a");
        #f1.close();
        #base_args.append("-v");
        #base_args.append(dirname + "/group:/etc/groupd:rw")
        #f1 = open(dirname + "/group", "a");
        #f1.close();
        #base_args.append("-v");
        #base_args.append(dirname + "/shadow:/etc/shadow:rw")
        #f1 = open(dirname + "/shadow", "a");
        #f1.close();
        #os.system("mkdir " + dirname + "/etc");
        #base_args.append(dirname + "/etc:/etc:rw");
        #string_bash_add_root = string_bash_add_root + "chmod -R 777 /etc\n"
    else:
        if(os.path.isfile(dirname + "/pacman.conf") == True):
            base_args.append("-v");
            base_args.append(dirname + "/pacman.conf:/etc/pacman.conf:ro");
            print("pacman.conf add to docker!")

    if(docker_system == 1):
        #docker
        string_bash_add_root = string_bash_add_root + "chown -R root:video /dev/dri\n";

    if(docker_disable_ipv6 == 1):
        if(docker_system == 1):
            #docker
            string_bash_add_root = string_bash_add_root + "sysctl net.ipv6.conf.eth0.disable_ipv6=1\n";
            print("docker_disable_ipv6 is 1")
            print("disable ipv6 in docker coantiner!")
            #sysctl net.ipv6.conf.all.disable_ipv6=1


    if(nvidia_dlss == 1 or nvidia_dlss_non_nvida_gpu == 1):
        if(nvidia_dlss_non_nvida_gpu == 1):
            nvidia_dlss = 1;
            string_bash_add_root = string_bash_add_root + "export PROTON_ENABLE_NVAPI=1\n";
            string_bash_add_root = string_bash_add_root + "export DXVK_NVAPI_ALLOW_OTHER_DRIVERS=1\n";
        else:
            string_bash_add_root = string_bash_add_root + "export PROTON_ENABLE_NVAPI=1\n";
        string_bash_add_root = string_bash_add_root + "export WINEDLLOVERRIDES=nvapi,nvapi64=n\n";

    if(wineesync_and_winefsync == 1):
        string_bash_add_root = string_bash_add_root + "export WINEESYNC=1\n";
        string_bash_add_root = string_bash_add_root + "export WINEFSYNC=1\n";

    if(pulseaudio_stotterfix == 1):
        string_bash_add_root = string_bash_add_root + "export PULSE_LATENCY_MSEC=60\n";

    if(amdgpu_nohyperz == 1):
        string_radv_pertest.append("nohyperz");

    if(amdgpu_pswave32 == 1):
        string_radv_pertest.append("pswave32");

    if(amdgpu_nv_ms == 1):
        string_radv_pertest.append("nv_ms");

    if(amdgpu_vrs != ""):
        string_bash_add_root = string_bash_add_root + "export RADV_FORCE_VRS="+ amdgpu_vrs + "\n";

    if(len(string_radv_pertest) != 0):
        tmp1 = ""
        b1 = 0;
        for tmp in string_radv_pertest:
            if(b1 == 0):
                b1 = 1;
                tmp1 = tmp1 + tmp;
            else:
                tmp1 = tmp1 + "," + tmp;
        string_bash_add_root = string_bash_add_root + "export RADV_PERFTEST=" + tmp1 + "\n";

    if(docker_input == "block"):
        string_bash_add_root = string_bash_add_root + "chmod 000 -R /dev/input\n";





    if(basename == "edit_config"):
        sav_and_exit = 0;
        os.system("sudo exit")
        start_json_edit_gui(dirname, docker_user, gpu_render, disk_device_name, zugriff_auf_media, sav_home_docker_folder, share_folder_daten,
                            share_folder1_aktiv, share_folder1, network_disable, steam_controller_bool, usb_sharing, usb_name, usb_hidraw_name,
                            docker_build, docker_input, maxmemory, maxcpus, network_host, portforwding, dbus_rw, pacman_cache, dns, ipv4,
                            wireguard_fix, nosudo, run_in_background, ttyon, pacman_pakgage_install, bluethoot_passthrough, hidraw_acs_overrides_patch,
                            ipv6_privacy, faketime, wine_32bit_speed_hak, read_only, read_only_password, amd_gpu_raytrasing_allgpus, amd_gpu_raytrasing_rdan2_only
                            , wine_fsr, manager_vm_fodler, optional_array, smart_acces_meomory, vulkan_device_name, steam_proton_run_without_steam, mango_hud, vkbasalt,
                            freesync, vsync, docker_system_bak, lxc_readonly_bak, lxc_network_mac, lxc_network_bridge_link, sav_and_exit, docker_disable_ipv6,
                            nvidia_dlss, nvidia_dlss_non_nvida_gpu, wineesync_and_winefsync, pulseaudio_stotterfix, amdgpu_nohyperz, amdgpu_pswave32, amdgpu_nv_ms, amdgpu_vrs,
                            pluseaudio_sdl_fix);
    if(basename == "edit_config_sav"):
        sav_and_exit = 1;
        start_json_edit_gui(dirname, docker_user, gpu_render, disk_device_name, zugriff_auf_media, sav_home_docker_folder, share_folder_daten,
                            share_folder1_aktiv, share_folder1, network_disable, steam_controller_bool, usb_sharing, usb_name, usb_hidraw_name,
                            docker_build, docker_input, maxmemory, maxcpus, network_host, portforwding, dbus_rw, pacman_cache, dns, ipv4,
                            wireguard_fix, nosudo, run_in_background, ttyon, pacman_pakgage_install, bluethoot_passthrough, hidraw_acs_overrides_patch,
                            ipv6_privacy, faketime, wine_32bit_speed_hak, read_only, read_only_password, amd_gpu_raytrasing_allgpus, amd_gpu_raytrasing_rdan2_only
                            , wine_fsr, manager_vm_fodler, optional_array, smart_acces_meomory, vulkan_device_name, steam_proton_run_without_steam, mango_hud, vkbasalt,
                            freesync, vsync, docker_system_bak, lxc_readonly_bak, lxc_network_mac, lxc_network_bridge_link, sav_and_exit, docker_disable_ipv6,
                            nvidia_dlss, nvidia_dlss_non_nvida_gpu, wineesync_and_winefsync, pulseaudio_stotterfix, amdgpu_nohyperz, amdgpu_pswave32, amdgpu_nv_ms, amdgpu_vrs,
                            pluseaudio_sdl_fix);
        basename = basename_bak;
    if(basename == "manager"):
        if(manager_vm_fodler == ""):
            print("manager_vm_fodler ist leer Bitte starte \"./edit_config\" und bei \"VM Folder for VM Manger:\" folder setzen!")
            exit()
        start_manager_gui(manager_vm_fodler);


    if(True):
        base_args.append("-v");
        base_args.append(dirname + "/empty:/etc/cmd:rw");
        base_args.append("-v");
        base_args.append(dirname + "/user_patched.bash:/etc/cmd/user_patched.bash:ro");
        base_args.append("-v");
        base_args.append(dirname + "/user_patched2.bash:/etc/cmd/user_patched2.bash:ro");
        os.system("mkdir -p " + dirname + "/empty")
        if(basename == "command"):
            patching_user(docker_user, "su " + docker_user + " - -c ",  custom_command, str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "system_only"):
            patching_user(docker_user, "su " + docker_user + " - -c ",  custom_command, str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "system_only2"):
            patching_user(docker_user, "su " + docker_user + " - -c ",  custom_command, str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "command_root"):
            patching_user(docker_user, "",  custom_command, str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "command_root_lxc"):
            patching_user(docker_user, "",  custom_command, str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "login"):
            patching_user(docker_user, "su "+docker_user , "bash", str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "login_root"):
            patching_user(docker_user, "su", "su", str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "openra-ra"):
            patching_user(docker_user, "su " + docker_user + " - -c ", "openra-ra", str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "firefox"):
            patching_user(docker_user, "su " + docker_user + " - -c ", "firefox", str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "firefox"):
            patching_user(docker_user, "su " + docker_user + " - -c ", "firefox", str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "firefox"):
            patching_user(docker_user, "su " + docker_user + " - -c ", "firefox", str(user_id), hidraw_acs_overrides_patch, ipv6_privacy, faketime, wine_32bit_speed_hak, string_bash_add, string_bash_add_root);
        elif(basename == "build"):
            pass;
        elif(basename == "run"):
            pass;
        elif(basename == "edit_config"):
            pass
        elif(basename == "manager"):
            pass
        else:
            print("Command not found!");
            exit();
    #base_args.append(os.path.split(dirname)[-1]);

    build_args = filter_docker_build(base_args);
    if(debug == 1):
        print(build_args)
    base_args.append(dirname_tmp);

    print("docker_system: ", docker_system)
    if(docker_system == 1):#docker system
        if(ttyon == 0):
            #gui aktiv
            args = {
                #"build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
                "build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
                "run": [base_args[0], "run"] + (base_args[1:]),
                "login": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "login_root": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "openra-ra": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "firefox": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "command": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "command_root": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "system_only": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "system_only2": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
            }
            if __name__ == "__main__":
                if(debug == 1):
                    print(args[basename]);
                #cmd = subprocessvhba-module-dkms.check_output(base_args[0] + , shell=True).decode().split("\n");
                #os.s(base_args[0], args[basename])
                cmd = args_array_to_str(args[basename]);
                if(basename == "build"):
                    #os.chdir(os.path.join(dirname , "archlinux_std_docker"));
                    #os.system("./build");
                    #os.chdir(dirname);
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                elif(basename == "login" or basename == "login_root" ):
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                else:
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                #print(cmd)
            if(basename == "build" and pacman_cache != ""):
                fertigfile = os.path.join(pacman_cache, "fertig");
                if(os.path.isfile(fertigfile) == True):
                    os.remove(fertigfile);
                if(debug == 1):
                    print("starting mod")
                start_thread_wait("bash install.bash");
                print("ERROR docker building system onlay mit ttyon set of 1!")
                exit(-1);
                while True:
                    if(start_thread_wait("./command_root 'pacman -Sy archlinux-keyring --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --downloadonly --cachedir /mnt/pacman_cache_rw/ && exit'") == 0):
                        break;
                start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
                #start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
                time.sleep(30);
                wait_build_fertig(fertigfile, dirname_tmp);
                dockerid = read_docker_ps(dirname_tmp);
                tmp = "";
                if(dockerid != ""):
                    print("sav docker image")
                    print(dockerid);
                    print(tmp);
                    cmd = "docker commit " + dockerid + " " + dirname_tmp;
                    os.system(cmd);
                    print("docker save!");
                    exit();
                else:
                    print("ERROR docker id not found");
                    exit(-1);
                thread_wait_is_exit();
            else:
                print("ERROR pacman cache is empty in config file!");
        elif(ttyon == 1):
            #ttyon 1 #gui off terminal on
            if(debug == 1):
                print("Terminal on!")
            args = {
                #"build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
                "build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
                "run": [base_args[0], "run"] + (base_args[1:]),
                "login": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "login_root": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "openra-ra": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "firefox": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "command": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "command_root": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "system_only": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "system_only2": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
            }
            if __name__ == "__main__":
                if(debug == 1):
                    print(args[basename]);
                #cmd = subprocessvhba-module-dkms.check_output(base_args[0] + , shell=True).decode().split("\n");
                #os.s(base_args[0], args[basename])
                cmd = args_array_to_str(args[basename]);
                if(basename == "build"):
                    #os.chdir(os.path.join(dirname , "archlinux_std_docker"));
                    #os.system("./build");
                    #os.chdir(dirname);
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                elif(basename == "login" or basename == "login_root" ):
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                else:
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                #print(cmd)

            if(basename == "build" and pacman_cache != ""):
                fertigfile = os.path.join(pacman_cache, "fertig");
                if(os.path.isfile(fertigfile) == True):
                    os.remove(fertigfile);
                print("starting mod")
                start_thread_wait("bash install.bash");
                print("downloading pacman data..")
                while True:
                    if(start_thread_wait("./command_root 'pacman -Sy archlinux-keyring --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --downloadonly --cachedir /mnt/pacman_cache_rw/ && exit'") == 0):
                        break;
                start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --needed  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
                #pacman free sapce error fix 0.2a
                #start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
                #start_thread
                time.sleep(30);
                wait_build_fertig(fertigfile, dirname_tmp);
                dockerid = read_docker_ps(dirname_tmp);
                tmp = "";
                if(dockerid != ""):
                    print("sav docker image")
                    print(dockerid);
                    print(tmp);
                    cmd = "docker commit " + dockerid + " " + dirname_tmp;
                    os.system(cmd);
                    print("docker save!");
                    exit();
                else:
                    print("ERROR docker id not found");
                    exit(-1);
                thread_wait_is_exit();
        else:
            #ttyon 2 #gui off terminal on docker checkpoit on
            build_args.append("-d");
            build_args.append("busybox");
            print("Terminal on!")
            args = {
                #"build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
                "build": [build_args[0], "build", "-f", dirname + "/src/Dockerfile", "-t" ,dirname_tmp ] +  (build_args[1:] + [dirname]),
                "run": [base_args[0], "run", "-i"] + (base_args[1:]),
                "login": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "login_root": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "openra-ra": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "firefox": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "command": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "command_root": [base_args[0], "run", "-i"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "system_only": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
                "system_only2": [base_args[0], "run", "-it"] + (base_args[1:] + ["bash", "-c", "/etc/cmd/user_patched.bash"]),
            }
            if __name__ == "__main__":
                if(debug == 1):
                    print(args[basename]);
                #cmd = subprocessvhba-module-dkms.check_output(base_args[0] + , shell=True).decode().split("\n");
                #os.s(base_args[0], args[basename])
                cmd = args_array_to_str(args[basename]);
                if(basename == "build"):
                    #os.chdir(os.path.join(dirname , "archlinux_std_docker"));
                    #os.system("./build");
                    #os.chdir(dirname);
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                elif(basename == "login" or basename == "login_root" ):
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                else:
                    os.system(cmd);
                    if(debug == 1):
                        print(cmd)
                #print(cmd)
            if(basename == "build" and pacman_cache != ""):
                fertigfile = os.path.join(pacman_cache, "fertig");
                if(os.path.isfile(fertigfile) == True):
                    os.remove(fertigfile);
                print("starting mod")
                start_thread_wait("bash install.bash");
                print("downloading pacman data..")
                print("ERROR docker building system onlay mit ttyon set of 1!")
                exit(-1);
                while True:
                    if(start_thread_wait("./command_root 'pacman -Sy archlinux-keyring --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --downloadonly --cachedir /mnt/pacman_cache_rw/ && exit'") == 0):
                        break;
                start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --needed  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
                #start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
                #start_thread
                time.sleep(30);
                wait_build_fertig(fertigfile, dirname_tmp);
                dockerid = read_docker_ps(dirname_tmp);
                tmp = "";
                if(dockerid != ""):
                    print("sav docker image")
                    print(dockerid);
                    print(tmp);
                    cmd = "docker commit " + dockerid + " " + dirname_tmp;
                    os.system(cmd);
                    print("docker save!");
                    exit();
                else:
                    print("ERROR docker id not found");
                    exit(-1);
                thread_wait_is_exit();
            else:
                print("ERROR pacman cache is empty in config file!");
            exit();
    else:
        #lxc
        out = lxc_converter_docker_array_reading(base_args);
        paths = out[0];
        variable = out[1];
        paths2 = out[2];
        devices = out[3];
        #import pdb
        #pdb.set_trace()
        if(basename != "build"):
            build_b1 = 0;
            if(lxc_mount_switch == 1):
                build_b1 = 2;
            elif(basename == "command_root_lxc"):
                build_b1 = 1;
                #os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs2")
                os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/mnt/2")
                #base_args.append("-v");
                #base_args.append("/var/lib/lxc/" + docker_build + "/rootfs2:/mnt/2:rw")
            else:
                if(lxc_readonly == 0):
                    if(basename == "system_only" or basename == "system_only2" or basename == "edit_config" or basename == "build"):
                        pass;
                    else:
                        s1 = input("Sind sie sich sicher das sie die VM schreibar starten wolle? y,n: ");
                        if(s1 == "j"):
                            pass;
                        elif(s1 == "y"):
                            pass;
                        else:
                            exit(-1)
            #if(dbus_rw == 2):
            #    print("Bitte dbus_rw deaktiviren!");
            #    exit(-1)
            #ttyon 1 #gui off terminal on
            if(debug == 1):
                print("Terminal on!")
            if __name__ == "__main__":
                #cmd = subprocessvhba-module-dkms.check_output(base_args[0] + , shell=True).decode().split("\n");
                #os.s(base_args[0], args[basename])
                out = lxc_converter_docker_array_reading(base_args);
                paths = out[0];
                variable = out[1];
                paths2 = out[2];
                devices = out[3];
                if(basename != "build"):
                    #os.system("sudo lxc-stop " + docker_build + " -k");
                    if(lxc_readonly == 1):
                        pass;
                        os.system("mkdir " + dirname + "/tmp")
                        os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/media/");
                        os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/etc/tmp/.X11-unix");
                        os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/etc/user");
                        os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/dev/bsg");
                        if(os.path.isdir("/var/lib/lxc/" + docker_build + "/rootfs/mnt/2/usr") == True):
                            os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/media");
                            os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/etc/tmp/.X11-unix");
                            os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/tmp/.X11-unix");
                            os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/etc/user");
                            os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/dev/bsg");



                        lxc_wait_file_look(docker_build);
                        lxc_tmp_auto_create_id = lxc_create_a_new_vm_copy_auto(docker_build);
                        lxc_remove_look_file(docker_build);
                        #tmp1 = lxc_covert_device_array_to_string(devices, docker_build + "_backing" + str(lxc_tmp_auto_create_id));
                        #lxc_start_vm_lxc_device_coammds = lxc_device_array_to_comdands(docker_build + "_backing" + str(lxc_tmp_auto_create_id), optical_disk[2]);
                        #lxc_string_add_config = lxc_string_add_config + tmp1[2];
                        applay_path(paths, docker_build + "_backing" + str(lxc_tmp_auto_create_id), variable, ttyon, dirname, ipv4, lxc_readonly, network_disable, lxc_network_mac, dns, build_b1, paths2, network_host, lxc_string_add_config, docker_build, docker_user, user_id, []);
                        #lxc_create_a_snapshot(docker_build);
                        print(lxc_start_vm_lxc_device_coammds);
                        os.system("sudo echo 1> start_lxc.log");
                        os.system("sudo lxc-start " + docker_build + "_backing" + str(lxc_tmp_auto_create_id) + " -o start_lxc.log");
                        #os.system("sudo lxc-config set " + docker_build + "_backing" + str(lxc_tmp_auto_create_id) +  " raw.lxc 'lxc.init_cmd = /sbin/init systemd.legacy_systemd_cgroup_controller=yes'")
                        #os.system("sudo lxc-start " + docker_build + "_backing" + str(lxc_tmp_auto_create_id) + " -o start_lxc.log");
                        #os.system("sudo lxc launch '" + docker_build + "_backing" + str(lxc_tmp_auto_create_id) + "' --vm");
                        time.sleep(2);
                        #lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + lxc_covert_device_array_to_string(devices, docker_build + "_backing" + str(lxc_tmp_auto_create_id))[0];
                        lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + lxc_device_array_to_comdands(docker_build + "_backing" + str(lxc_tmp_auto_create_id), devices, optical_disk);
                        #os.system("sleep 5 && " + lxc_start_vm_lxc_device_coammds)
                        lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + "sudo lxc-config device add " + docker_build + "_backing" + str(lxc_tmp_auto_create_id) + " mysocket proxy connect=unix:/var/run/dbus/system_bus_socket listen=unix:/var/run/dbus/system_bus_socket bind=container\n";
                        os.system(lxc_start_vm_lxc_device_coammds)
                        os.system("sudo lxc-attach -n " + docker_build + "_backing" + str(lxc_tmp_auto_create_id) + " -e  -- /etc/cmd/user_patched.bash");
                        os.system("sudo lxc-stop " +  docker_build + "_backing" + str(lxc_tmp_auto_create_id) + " -k")
                        #exit();
                        lxc_remove_a_new_vm_copy(docker_build, lxc_tmp_auto_create_id);
                    else:
                        #tmp1 = lxc_covert_device_array_to_string(devices, docker_build + "_backing" + str(lxc_tmp_auto_create_id));
                        #lxc_start_vm_lxc_device_coammds = lxc_device_array_to_comdands(docker_build + "_backing" + str(lxc_tmp_auto_create_id), optical_disk[2]);
                        #lxc_string_add_config = lxc_string_add_config + tmp1[2];
                        if(basename == "command_root_lxc"):
                            applay_path(paths, docker_build, variable, ttyon, dirname, ipv4, lxc_readonly, network_disable, lxc_network_mac, dns, build_b1, paths2, network_host, lxc_string_add_config, docker_build, docker_user, user_id, []);
                        else:
                            applay_path(paths, docker_build, variable, ttyon, dirname, ipv4, lxc_readonly, network_disable, lxc_network_mac, dns, build_b1, paths2, network_host, lxc_string_add_config, docker_build, docker_user, user_id, [docker_build + "/rootfs/mnt/2"]);
                        #lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + lxc_covert_device_array_to_string(devices, docker_build)[0];
                        os.system("sudo echo 1> start_lxc.log");
                        os.system("sudo lxc-start " + docker_build + " -o start_lxc.log");
                        #os.system("sudo lxc-config set " + docker_build + " raw.lxc 'lxc.init_cmd = /sbin/init systemd.legacy_systemd_cgroup_controller=yes'")
                        #os.system("sudo lxc-start " + docker_build + " -o start_lxc.log");
                        #os.system("sudo lxc launch '" + docker_build  + "' --vm");
                        time.sleep(2);
                        #lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + lxc_covert_device_array_to_string(devices, docker_build)[0];
                        lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + lxc_device_array_to_comdands(docker_build, devices, optical_disk);
                        #os.system("sleep 5 && " + lxc_start_vm_lxc_device_coammds)
                        lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + "sudo lxc-config device add " + docker_build + " mysocket proxy connect=unix:/var/run/dbus/system_bus_socket listen=unix:/var/run/dbus/system_bus_socket bind=container\n";
                        os.system(lxc_start_vm_lxc_device_coammds)
                        os.system("sudo lxc-attach -n " + docker_build + " -e  -- /etc/cmd/user_patched.bash");
                        os.system("sudo lxc-stop " + docker_build + " -k")
                    if(lxc_readonly == 1):
                        pass;
                        #lxc_create_a_snapshot_back(docker_build);
                    #lxc-attach -n archlinux_std_docker --elevated-privileges -- /etc/cmd/user_patched.bash

                    #/etc/cmd/user_patched.bash
        elif(basename == "build" and pacman_cache != ""):
                    build_b1 = 1;
                    if(lxc_readonly == 1):
                        print("ERROR lxc_readonly in config is on!");
                        print("pleasee set to 0 for build thhe vm!");
                        exit(-1);
                    #if(dns == ""):
                    #    print("ERROR dns server in config is empty!");
                    #    exit(-1);
                    if(faketime != ""):
                        print("ERROR dns faketime in config biite lerr lassen!");
                        exit(-1);
                    if(os.path.isfile(dirname + "/pacman.conf") == False):
                        print("ERROR file pacman.conf fehlt zum bauen in folder!");
                        exit(-1);
                    if(os.path.isfile(dirname + "/mirrorlist") == False):
                        print("ERROR file mirrorlist fehlt zum bauen in folder!");
                        exit(-1);
                    #if(ipv4 == ""):
                    #    print("ERROR ipv4 must not be empty!");
                    #    exit(-1);
                    if(network_disable == 1):
                        print("ERROR network_disable must be to off!");
                        exit(-1);
                    fertigfile = os.path.join(pacman_cache, "fertig");
                    if(os.path.isfile(fertigfile) == True):
                        os.remove(fertigfile);
                    #lxc_start_vm_lxc_device_coammds = lxc_start_vm_lxc_device_coammds + lxc_covert_device_array_to_string(devices, docker_build)[0];

                    if(lxc_exist_newtworkdevice(network_host) == 0):
                        print("create br0 network bridge!")
                        os.system("sudo brctl addbr br0");
                        #eth0 = lxc_find_eth0_network_Device();
                        os.system("sudo brctl addif br0 " + lxc_network_bridge_link);
                        os.system("sudo ip link br0 up");
                        os.system("sudo ip link br0 down");
                        os.system("sudo ip link br0 up");
                        os.system("sudo ip link br0 down");
                        os.system("sudo ip link br0 up");
                        ##
                        os.system("sudo ifconfig br0 up");
                        os.system("sudo ifconfig br0 down");
                        os.system("sudo ifconfig br0 up");
                        os.system("sudo ifconfig br0 down");
                        os.system("sudo ifconfig br0 up");
                    os.system("sudo lxc-stop " + docker_build + " -k");
                    os.system("sudo lxc-destroy -n " + docker_build);
                    os.system("sudo DOWNLOAD_KEYSERVER=\"keyserver.ubuntu.com\" lxc-create -n " + docker_build +" -t download -- --dist archlinux --release current --arch amd64");
                    os.system("sudo chmod 777 /var/lib/lxc/" + docker_build)
                    os.system("sudo chmod 777 /var/lib/lxc/" + docker_build +"/config")
                    #os.system("sudo rm -r /var/lib/lxc/" + docker_build + "/rootfs");
                    #os.system("sudo btrfs sub cr /var/lib/lxc/" + docker_build + "/rootfs")
                    #os.system("sudo echo \"1\" > /var/lib/lxc/" + docker_build +"/config");
                    #os.system("sudo chmod 777 /var/lib/lxc/" + docker_build)
                    #os.system("sudo chmod 777 /var/lib/lxc/" + docker_build +"/config")
                    #os.system("sudo pacstrap /var/lib/lxc/" + docker_build + "/rootfs base dhcpcd")
                    applay_path(paths, docker_build, variable, ttyon, dirname, ipv4, lxc_readonly, network_disable, lxc_network_mac, dns, build_b1, paths2, network_host, lxc_string_add_config, docker_build, docker_user, user_id, []);
                    print("starting mod");
                    start_thread_wait("bash install.bash");
                    print("downloading pacman data..")
                    #start_thread_wait
                    #while True:
                    #    if(start_thread_wait("./command_root 'pacman -Sy base base-devel archlinux-keyring --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --downloadonly --cachedir /mnt/pacman_cache_rw/ && exit'") == 0):
                    #        break;
                    #start_thread("./command_root 'pacman -Syu  base base-devel  archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --needed  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread

                    #old version 0.20h mod 1
                    #start_thread_wait
                    #os.system("./command_root_lxc 'curl http://ftp.agdsn.de/pub/mirrors/archlinux/core/os/x86_64/archlinux-keyring-20220424-1-any.pkg.tar.zst -o 1.zstd\npacman -U 1.zstd --noconfirm'");

                    #exit();
                    while True:
                        if(start_thread_wait("./command_root_lxc 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && pacman -Syu " + pacman_pakgage_install + " --noconfirm -y --downloadonly --cachedir /mnt/pacman_cache_rw/ && exit'") == 0):
                            break;
                    #start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig &&   exit '");#start_thread
                    #end old version
                    #os.system("sudo mkdir -p /var/lib/lxc/" + docker_build + "/rootfs")
                    #os.system("sudo echo '' >/var/lib/lxc/" + docker_build +"/config")
                    #start_thread("sudo mount -B  '/NAS/Daten/Backup/archlinux_pacman_cache/cache' /var/cache/pacman/pkg -o ro  && mount -B  '/NAS/Daten/Backup/archlinux_pacman_cache/cache' /var/lib/lxc/" + docker_build + "/rootfs/var/cache/pacman/pkg -o ro&& sudo pacstrap /var/lib/lxc/" + docker_build + "/rootfs " + pacman_pakgage_install + " && sudo umount /var/cache/pacman/pkg");#start_thread

                    #os.system("sudo mount -B  '/NAS/Daten/Backup/archlinux_pacman_cache/cache' /var/cache/pacman/pkg -o ro");
                    #os.system("sudo mount -B  '/NAS/Daten/Backup/archlinux_pacman_cache/cache'  /var/lib/lxc/" + docker_build + "/rootfs/var/cache/pacman/pkg -o ro");
                    #os.system("sudo pacstrap /var/lib/lxc/" + docker_build + "/rootfs " + pacman_pakgage_install);
                    os.system("sudo chmod 777 /var/lib/lxc/" + docker_build)
                    os.system("sudo chmod 777 /var/lib/lxc/" + docker_build +"/config")
                    os.system("sudo mkdir /var/lib/lxc/" + docker_build + "/rootfs/tmp")
                    os.system("sudo lxc-stop " + docker_build + " -k");

                    #start_thread_wait("./command_root 'mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig &&  exit '");
                    os.system("./command_root_lxc 'pacstrap  /mnt/2 --cachedir /var/cache/pacman/pkg dhcpcd " + pacman_pakgage_install + "\n chroot /var/lib/lxc/" + docker_build + "/mnt/2/ /usr/bin/useradd -m -g users -G wheel,audio,video -s /bin/bash " + docker_user + " \nexit '");

                    os.system("sudo lxc-stop " + docker_build + " -k");
                    #os.system("sudo rm -r /var/lib/lxc/" + docker_build + "/rootfs")
                    #os.system("sudo mv /var/lib/lxc/" + docker_build + "/rootfs2 /var/lib/lxc/" + docker_build + "/rootfs3")
                    #os.system("sudo mv /var/lib/lxc/" + docker_build + "/rootfs /var/lib/lxc/" + docker_build + "/rootfs2")
                    #os.system("sudo mv /var/lib/lxc/" + docker_build + "/rootfs3 /var/lib/lxc/" + docker_build + "/rootfs")
                    os.system("sudo chmod -R 777  /var/lib/lxc/" + docker_build + "/rootfs/")

                    os.system("sudo chroot /var/lib/lxc/" + docker_build + "/rootfs/mnt/2/ /usr/bin/useradd -m -g users -G wheel,audio,video,input,optical,cdemu,render  -s /bin/bash " + docker_user);

                    os.system("./system_only3 exit")
                    #os.system("./command_root_lxc 'useradd -m -g users -G video,audio " + docker_user + "'");
                    #start_thread("./command_root 'pacman -Sy archlinux-keyring archiso --noconfirm -y --cachedir /var/cache/pacman/pkg && mkdir /mnt/2 &&  mount -B / /mnt/2 && mount -B /var/cache/pacman/pkg/ /mnt/2/var/cache/pacman/pkg/ && pacman -Syu  " + pacman_pakgage_install + " --noconfirm -y --cachedir /var/cache/pacman/pkg --root /mnt/2  && echo 1 > /mnt/pacman_cache_rw/fertig && sleep 180 &&  exit '");#start_thread
                    #start_thread
                    time.sleep(5);
                    exit();

        else:
            print("pacman chache fodler in config empty!")
    exit();

main();
exit();
